# 第七章 函数与特殊函数  

函数是一个在自然科学、工程技术，甚至在某些社会科学中被广泛应用的数学概念，无论在初等数学还是高等数学中，无论在基础课还是专业课中，大家都会经常与函数打交道，以函数为基本工具解决各种各样的数学问题和专业问题。然而，从严格意义角度给函数下个定义并不是一件容易的事情。有人会说，函数不就是一个集合到另外一个集合的映射吗？或者说，函数就是对于某个集合中的任一元素，在另外一个集合中存在唯一元素与之对应。这不就是函数的定义？如果函数是这样定义的话，那么映射或对应又怎么定义呢？这正是函数定义的困难所在。事实上，自函数概念首次被德国数学家被莱布尼茨提出以来，其定义一直没有得到很好地解决，因为没有人能够准确地回答什么叫映射或者对应。直到在集合论和关系理论出现后，人们才以关系理论为工具完美地解决了函数的定义。具体地说，函数就是一种满足单值性要求的特殊二元关系。通过关系模型定义函数，就用关系模型的特性来诠释映射或对应概念的含义。作为关系模型的一个具体应用，本章将从特殊关系的角度来介绍函数的基本知识及其应用，包括函数的基本概念、函数的基本运算，以及若干重要的特殊函数，例如特征函数、散列函数和置换函数等。  

## § 7.1 函数的基本概念  

函数概念的来源可以一直追溯到伟大的意大利物理家、天文学家和哲学家伽利略，伽利略在十七世纪就观察到了两个变量之间的制约关系，并用文字和比例的语言表达变量之间的函数关系。笛卡尔在他的解析几何中，已注意到一个变量对另一个变量的依赖关系，但未意识到要提炼函数概念，直到后来莱布尼茨第一个使用函数一词来表示一个量，并将函数值的变化看成是曲线上一个点的运动，才真正诞生函数的概念。人们通常使用的函数符号$f(x)$由欧拉发明。值得一提的是，欧拉是目前世界上最多产的数学家，其数学成果在他去世50 年后才基本上整理完成，但直到现在还没有全部整理完成。  

函数是数学中一个非常重要的内容,既是沟通各种学科之间的桥梁，也是读者今后学习其它相关课程的重要基础。函数方法是实际问题求解的一个基本方法论，在遇到实际问题的时候，很多情况下可以使用函数知识构造出相关的函数模型,进而通过对函数问题的研究实现对实际问题的求解。例如，深度学习中构造分类器的基本策略就是建立一个函数模型并通过数据训练使得该函数模型不断逼近所求的分类器函数。本节主要从集合与关系的角度介绍函数的基本概念，包括函数的集合定义、函数的基本类型和一些常用的特殊函数。  

### 7.1.1 函数的集合定义  

在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  

【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  

$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  

从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  

(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$ 

（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  

如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系： 

（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。 

例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：  
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$

则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  



由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  

【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  

从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  



现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  

【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  



 根据上述定理，可得到如下函数集定义及其表示方法：  

【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  

根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$



通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  

（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。 

（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$

（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。 

下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  

【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  

（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。

（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。 

在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  

下面定理给出了子集像的集合运算性质：  

【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  

$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$



上述定理的第（2）结论等号不成立。  

事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  

$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$

故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  

至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。  

### 7.1.2 函数的基本类型  

从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  

【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  

（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。 

（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。

 （3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  

可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  



由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  

【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。  



### 7.1.3 常用特殊函数  

数学中常用的特殊函数有很多，在初等数学和高等数学中都有大量的分析讨论，例如三角函数、指数函数等基本初等函数，不再一一赘述。在此，我们主要介绍在计算机科学应用中经常使用的一些函数，例如恒等函数、常函数、取整函数、布尔函数、自然映射函数等。下面给出这些常用特殊函数的定义。  

【定义7.6】设$𝐴$和$B$是任意给定的两个非空集合：

 （1）设$f\colon A\to B$，若有$c\in B$，对$\forall x\in A$都有$f(x)=c$，则称$f\colon A\to B$是常函数。  

（2）$𝐴$上的恒等函数就是$𝐴$的恒等关系$I_{A}$，对$\forall x\in A$，有$I_{A}(x)=x$。 

（3）对实数 $x$ ， $f(x)$ 取不小于 $ x$ 的最小整数，则称 $f(x)$ 为上取整函数， 记为 $f(x)=\left\lceil x\right\rceil$  

（4）对实数$x$，$f(x)$取不大于$ x$的最大整数，则称$f(x)$为下取整函数，记为$f(x)=\lfloor x\rfloor$

（5）如果$f(x)$是从集合$𝐴$到$B=\{0,1\}$上的函数，则称$f(x)$为布尔函数。  

（6）设$R$是$𝐴$上的等价关系，$A/R$是$𝐴$在关系$R$上的商集，令$g\colon A\to A/R$，$g(x)=[x]_{R}$则称$g$是从$A$到$A/R$的自然映射。  



## § 7.2 函数的基本运算  

函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。  

### 7.2.1 函数的复合运算  

前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  

【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：

$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$

 是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  



根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  

（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  

（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  

（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  

下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：

 【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  

（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射； 

（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射； 

（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  



需要注意的是上述定理的逆不成立，但有以下结论： 

【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  

（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射； 

（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射； 

（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。  



### 7.2.2 函数的逆运算  

在一般关系$𝑅$的求逆运算中，任意关系都可进行求逆运算而得到其逆关系，但是对于任意一个函数$𝑓$来说，只能保证它的逆$f^{-1}$是一个二元关系，并不能保证$f^{-1}$一定是函数关系。因此，在求一个函数的逆运算时，必须对该函数做一些特殊的要求。  

【定义7.7】设$f\colon A\to B$的函数关系，如果其逆关系：  

$$
f^{-1}=\{\langle y,x\rangle|x\in A\land y\in B\land\langle x,y\rangle\in f\}\quad\text{(7-2)}
$$

是一个从$B$到$𝐴$的函数关系，则函数$f$可逆，并称$f^{-1}$是函数$f$的逆函数或反函数。  

由上述定义可可知，如果函数$f$可逆，则$f^{-1}$作为一个从$B$到$𝐴$的函数，集合$ B$中每个元素都有$ f^{-1}$下的像，而根据逆关系的定义，$B$中每个元素在函数$f^{-1}$下的像其实就是该元素在函数$f$下的原像，故$f$是从$𝐴$到$B$的满射。另一方面，$f^{-1}$作为一个函数，集合$ B$中每个元素都有$A$中唯一的元素与之对应。从函数$ f$的角度看，就是$𝐴$中不同的元素对应不同的像，因此，函数$f$是单射。综上所述，函数$f$存在逆函数$f^{-1}$当且仅当$f$是双射。  



【定理7.7】设$f\colon A\to B$的双射函数，则$f$的逆函数$f^{-1}$也是从$B$到$𝐴$的双射函数。 



下面定理给出了任一双射函数与其函数反函数及恒等函数之间的关系：  

【定理7.8】设$𝑓$:$A\rightarrow B$的双射函数，则有：  

$$
(1)f^{-1}\circ f=I_{B};\mathrm{~(~2~)~}\,f\circ f^{-1}=I_{A};\mathrm{~(~3~)~}\,I_{A}\circ f=f\circ I_{B}=f。
$$

其中$I_{A}$和$I_{B}$分别表示集合$𝐴$和集合 $B$上的恒等函数。  



### 7.2.3 函数的递归运算  

前面从二元关系的角度讨论了函数关系的复合运算和逆运算，我们还可以将关系的幂运算引入函数关系之中。如前所述，关系的幂运算是一种特殊的复合运算，就是关系通过不断地与其自身进行复合从而产生新的关系。由于关系的复合运算满足结合律，故给定次数下的复合运算结果是唯一确定的。同样，一个函数关系也可以通过不断与其自身进行复合运算产生新的函数关系，由此可得函数迭代与递归运算的概念。  

【定义7.8】假设$𝐴$是任一给定的非空集合，$f(x)$是$A$上的某个函数，$n$个相同函数$f(x)$的复合运算称为对$f(x)$的$n$次迭代运算，运算结果记为$f^{n}(x)$，称为$f(x)$的$n$次迭代函数，并约定$f(x)$的0 次迭代函数为其自变量$x$，即有：  

$$
f^{(n)}(x)=f(f^{(n-1)}(x))\wedge f^{(0)}(x)\quad\text{(7-3)}
$$

其中$f^{(0)}(x)=x。$ 

迭代是函数的一个非常重要的运算，在很多情况下可使用函数迭代得到新的函数。例如，假设$f(x)$是自然数集上的后继函数，即有$f(x)=x+1$，则有$f^{(n)}(x)=~x+n$。还可以使用迭代方法解方程或方程组，例如牛顿迭代法、雅可比迭代法、高斯迭代法等等，有兴趣的读者可以数值分析的课程的相关内容，这里不再赘述。下面将函数迭代的概念做进一步推广，给出并讨论函数递归运算的概念。  

首先看一个引例。西萨·班·达依尔发明了国际象棋，国王问他需要什么奖赏，他说：“陛下，请您在这张棋盘的第1 个小格里赏给我一粒麦子，在第2 个小格里给2 粒，第3 个小格给4 粒，以后每一小格都比前一小格加一倍，直到摆满这64 个棋盘格”  

那么需要多少粒麦子呢？可以按如下方法计算：  

$$
f(1)=1;f(2)=2;f(3)=4;\cdots\cdots;f(n)=2*f(n-1)
$$

最后得到：$f(64)=2^{64-1}=18446744073709551615.$是一个非常大的数字。  

上面的算式$f(n)=2*f(n-1)$表达的就是一个递归运算。该算式采用以步长为1 的逐步推进的方式，通过以$f(n-1)$为变量的某个具体表达式计算$f(n)$。  

下面给出函数递归运算的具体定义：  

【定义7.9】对于某一函数$f(x)$，其定义域是集合$𝐴$，那么若对于$𝐴$集合中的某一个值$x_{n}$，其函数值$f(x_{n})$由以$f(x_{n-1}),f(x_{n-2}),\cdots,f(x_{n-k})$变量的某个表达式确定决定，即有：  

$$
f(x_{n})=S(f(x_{n-1}),f(x_{n-2}),\cdots,f(x_{n-k}))\quad\text{(7-4)}
$$

则称$f(x)$为一个$k$阶递归函数。  

递归函数的思想就是将复杂问题分解成若干简单且相同的子问题，将复杂的原问题转换为简单子问题的某种重复，通过简单子问题的机械重复得到复杂问题的解。  

例如，下列两个函数均为递归函数。  

（1）阶乘函数：  

$$
Fact(n)=\left\{\begin{matrix}1&&n=0\\&n*Fact(n-1)&&n>0\end{matrix}\right.
$$

（2）2 阶的Fibonacci 数列：  

$$
Fib(n)=\begin{cases}0&\quad&n=0\\1&\quad&n=1\\&\quad&Fib(n-1)+Fib(n-2)&\quad\text{否则}\end{cases}
$$

递归函数的上述思想非常符合计算机程序设计的思维方式。因此，递归方法是算法与程序设计的一个有效方法,使用递归方法能使程序变得简洁和清晰。  

值得注意的是，并不是任何函数都适合采用递归的形式进行计算。使用递归方式计算函  

数必须具备如下两个基本条件：  

（1）函数存在递归结束条件及结束时的值，称之为递归出口； 

（2）函数能够用递归形式表示，且递归向终止条件发展，称递归表达式为递归体。  



## § 7.3 集合的特征函数  

前面我们从二元关系与集合的角度介绍和讨论函数的相关知识，包括函数的集合定义和函数的关系运算。在本节，我们考虑相反的问题，就是如何以函数为基本工具来解决集合的相关问题。具体地说，就是通过引入集合特征函数将关于集合的表示和运算转化为函数的表示和运算，将关于集合问题的求解转化为关于函数问题的求解。  

### 7.3.1 特征函数的概念  

首先，解决如何使用函数来表示集合的问题。为此，给出如下特征函数的概念：  

【定义7.10】假设$U$为任一给定的集合，对于$U$的任一子集$𝐴$特征函数$\chi_{A}$定义为一个从$U$到集合{0,1}二值函数：  

$$
\chi_{A}(a)=\left\{\!\!\begin{array}{c}{{1,~~~~~~~~~~~~~~~~~~~~~~~~~a\in A~~~}}\\ {{0,~~~~~~~~~~~~~~~~~a\in U-A~~~}}\end{array}\right.\quad\quad\quad\quad\quad(7-5)
$$

由以上定义可知，集合$U$的任意一个子集$𝐴$都有一个与之相对应的特征函数$\chi_{A}$。例如，对于集合$U=\{a,b,c\}$的子集$A=\{a\}$，则有：  

$$
\chi_{A}(a)=1\,,\,\,\,\chi_{A}(b)=0\,,\,\,\,\chi_{A}(c)\,。
$$

此外，根据特征函数定义显然有：空集的特征函数恒为0，$U$的特征函数恒为 1.即：  

$$
(1)A=\emptyset\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=0);\;\;(\;2)\;\;A=U\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=1)\,\mathrm{{s}}
$$

  

### 7.3.2 特征函数的运算  

有了集合的特征函数之后，集合之间的关系就可以用其特征函数的关系表达，集合之间的运算就转化为其特征函数之间的运算。  

【定理7.9】给定全集$U$，$A\subseteq U$和$B\subseteq U$，则对所有$x\subseteq U$，成立下列关系式：$(1)\chi_{\bar{A}}(x)=1-\chi_{A}(x);~~(2)~~\chi_{A\cap B}(x)=\chi_{A}(x)\cdot\chi_{B}(x)=m i n\{\chi_{A}(x),\chi_{B}(x)\};$ $(3)\chi_{A\cup B}(x)=\chi_{A}(x)+\chi_{B}(x)-\chi_{A\cap B}(x)=m a x\{\chi_{A}(x),\chi_{B}(x)\};$ $(4)\chi_{A}(x)\leq\chi_{B}(x)\Leftrightarrow A\subseteq B;\;\;(5)\chi_{A}(x)=\chi_{B}(x)\Leftrightarrow A=B;$ $(6)\chi_{A-B}(x)=\chi_{A\cap\bar{B}}(x)=\chi_{A}(x)\cdot\chi_{\bar{B}}(x)=\chi_{A}(x)-\chi_{A\cap B}(x)\,。$  



## § 7.4 有限集的置换函数  

有限集上的函数是一类很特别的函数，具有很多非常重要而有趣的性质。如前所述，有限集$𝐴$上的单射必是满射，满射也必是单射。因此，有限集$𝐴$上的函数只有两种基本类型，一 种是双射函数，另外一种则为既非单射也非满射的函数。不难看出，有限集$𝐴$上双射函数其实就是$𝐴$上所有元素的一个全排列，因此，有限集$𝐴$上双射函数也称为置换函数。本节主要讨论有限集$𝐴$上双射函数的概念与关系运算性质，包括置换函数的基本概念、置换函数的运算性质、置换函数的轮换分解。  

### 7.4.1  置换函数的概念  

设$𝐴$是一个任意给定的非空有限集，由函数计数原理知，$𝐴$上所有不同双射函数个数也是有限的。因此，可将这些所有不同双射函数放在一起组成一个集合，并将该集合作为分析讨论𝐴上双射函数性质的背景或载体。为此，下面给出双射函数集的概念：  

【定义7.11】设$A=\{x_{1},x_{2},\cdots,x_{n}\}$是一个有穷集合， $𝐴$上所有的双射函数构成的集合称为𝐴上的双射函数集或可逆函数集。记为$F_{A}$。  

对于双射函数集$F_{A}$，显然有如下性质：  

$( 1) \forall f, g\in F_A\Rightarrow f\circ g\in F_A\wedge$ $g\circ f\in F_A。 ( 2)$ $\forall f, g, h\in F_A$ $\Rightarrow ( f\circ g) \circ h= f\circ ( g\circ$

$h)$。

(3) $\forall f\in F_{A}\Rightarrow f\circ I_{A}= I_{A}\circ f= f$。

(4) $\forall f\in F_{A}$ $\Rightarrow f^{- 1}\in F_{A}$



【定义7.12】设$ A=\{x_{1},x_{2},\cdots,x_{n}\}$是一个有限集合，从$𝐴$到$𝐴$的双射函数称为$𝐴$上的一个置换函数，简称为置换或排列，记为$P{\mathrel{:}}A\to A$，$A$的基数$n$称为置换的阶。  

由于置换函数表示的是有限集合上元素的全排列，故通常使用字母$P$或$\pi$作为置换函数的函数名，即有：  

$P=\begin{pmatrix}x_1&x_2&x_3&&\cdots&x_n\\P(x_1)&P(x_2)&P(x_3)&&\cdots&P(x_n)\end{pmatrix}\quad(7-7)$

上式其中第一行是集合$ A$的元素按顺序列出，第二行元素是$A$中元素对应的函数值。显然序列$P(a_{1}),P(a_{2}),\cdots,P(a_{n})$是$𝐴$中元素的重排，恰好对应一个$ N=\{1,2,\cdots,n\}$全排列。  

显然有$F_{A}=\left\{f\middle|f\right.$是𝐴中的置换}，即可逆函数集是$𝐴$中所有置换的集合。由于 $n$元有限集中共有$n\,!$个不同的置换函数，故有$|F_{A}|=n!$，因此，有时亦将$𝐴$的可逆函数集记为𝐴！。  



### 7.4.2 置换函数的运算  

置换是一种特殊的双射函数，关于函数的求逆运算和复合运算在置换中完全适用。因此，可直接将一般函数的逆运算和复合运算作为置换函数的逆运算和复合运算。  



从上例子可知，集合$𝐴$中置换函数的逆运算和复合运算结果还是$𝐴$的一个置换。从排列的角度看，置换函数的逆运算其实就是将置换的上下两排元素进行颠倒排放，即将下面一排移到上面，同时将上面一排移到下面，然后将数对按第一个元素（上面元素）的升序排列。  

虽然可以直接将一般函数的复合运算作为置换函数的复合运算，但是从排列的角度看，直接使用置换函数的复合运算会对排列的分析带来一些不便。为此，我们对置换函数的复合运算规则稍加调整，得到如下置换函数乘积运算的概念：  

【定义7.13】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$的任意两个$n$阶置换函数$\pi$和$\tau$ ：

$\begin{gathered}\pi=\begin{pmatrix}a_1&a_2&a_3&\cdots&a_n\\\pi(a_1)&\pi(a_2)&\pi(a_3)&\cdots&\pi(a_n)\end{pmatrix}\\\tau=\begin{pmatrix}a_1&a_2&a_3&\cdots&a_n\\\tau(a_1)&\tau(a_2)&\tau(a_3)&\cdots&\tau(a_n)\end{pmatrix}\end{gathered}$

则$\pi$和$\tau$的乘积$\pi\cdot\tau$定义为：  

$\pi\cdot\tau=\begin{pmatrix}a_1&a_2&a_3&\cdots&a_n\\\pi(\tau(a_1))&\pi(\tau(a_2))&\pi(\tau(a_3))&\cdots&\pi(\tau(a_n))\end{pmatrix}\quad\text{(7-8)}$

在不引起混淆的情况下，通常省略乘法符号，即将$\pi\cdot\tau$简写为$\pi\tau$  

从上述定义可以看出，置换函数乘积运算与复合运算之间没有本质上的区别，只是表达形式上有所差异，具体地说，就是它们之间的运算次序正好相反，即$\pi\cdot\tau=\tau\circ\pi$。  



### 7.4.3  置换的轮换分解  

细心的读者可能会发现，前面几个置换函数例题的排列元素都只有3 个，这是主要因为置换数目的增长速度为排列元素数目的阶乘${n!}$，如果$n$比较大，则问题的规模会迅速增大而变得不可行。因此，对于有限集合$A=\{a_{1},a_{2},\cdots,a_{n}\}$上的置换，当$n$比较大时，就必须置换进行分解。现在我们考察对置换进行分解的具体方法。  

首先考察一种特殊的置换，在这种置换中的一些元素的函数映射呈现出一种循环的状态，而其余元素则的映射为恒等映射。例如，对于如下置换：  

$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}$

元素1 映射到4，元素4 映射到2，元素2 映射到3，元素3 映射到5，元素5 映射到1，然后循环。置换中这5 个元素1, 4, 2, 3, 5形成一个循环，而其余元素6, 7, 8则保持恒等映射，此时称这样的置换为长度为5 的轮换，记为(1, 4, 2, 3, 5),即有：

$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}=(1,4,2,3,5)  $

轮换的具体定义如下：  

【定义7.14】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$是任一非空有限集合，如果$𝐴$上的某个置换$P$把元素$a_{1}$变成$a_{2}$, $a_{2}$变成$a_{3},\ \cdots,a_{k-1}$变成$a_{k}$，又把$a_{k}$变成$a_{1}(k\leq n)$，但别的元素（如果有的话）都不变，则称$ P$是一个长度为$k$的轮换，简称为$\pmb{k}{-}$轮换，并将其记为$(a_{1},a_{2},\cdots,a_{k})$。其中长度为2 的轮换称为对换。  

由上述定义可知，轮换是置换另一种表达方式，它以元素变化次序为序，描述一种轮换过程$(a_{1},a_{2},\cdots,a_{k})=(a_{2},a_{3},\cdots,a_{k}a_{1})=\cdots=(a_{k},a_{1},\cdots,a_{k-1})。$例如对于轮换$(1,4, 2, 3, 5)$，有：$(1,4,2,3,5)=(\begin{array}{ccc}4,2,3,5,1)=(&2,3,5,1,4)=\cdots=(5,1,4,2,3)。\end{array}$

值得注意的是，虽然轮换表达方式比置换更加简洁，轮换不能表达其所在置换的元素数目，需要采用其它方式说明置换的元素数目。  



现在考察轮换的运算。由于轮换是一种特殊的置换，故可像置换那样进行乘法运算。例如，对于集合$ A=\{1,2,3,4,5,6\}$上的两个轮换$(4,1,3,5)$和$(5,6,3)$，则可计算它们的乘积：  

$(4,1,3,5)\cdot(5,6,3)=\begin{pmatrix}1&2&3&4&5&&6\\3&2&5&1&4&&6\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&&6\\1&2&5&4&6&&3\end{pmatrix}$

$=\begin{pmatrix}1&2&3&4&5&&6\\3&2&4&1&6&&5\end{pmatrix}$

$\begin{aligned}(5,6,3)\cdot(4,1,3,5)&=\begin{pmatrix}1&2&3&4&5&6\\1&2&5&4&6&3\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&6\\3&2&5&1&4&6\end{pmatrix}.\\&=\begin{pmatrix}1&2&3&4&5&6\\5&2&6&1&4&3\end{pmatrix}\end{aligned}$

可以看出$(4,\!1,\!3,\!5)\cdot(5,\!6,\!3)\neq(5,\!6,\!3)\cdot(4,\!1,\!3,\!5)$。因此，轮换的乘法不满足交换律。 显然，并不是每个置换都能成为轮换。例如，对于如下8 阶置换：  

$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$

其不可能是轮换。但我们发现：  

$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$

$$
=\bigl(\begin{matrix}1&2&3&4&5&6&7\\3&2&6&4&5&1&7\end{matrix}\bigr)\bigl(\begin{matrix}1&2&3&4&5&6&7\\1&5&3&4&2&6&7\end{matrix}\bigr)
$$

$\quad\quad\quad\quad\quad=(\begin{matrix}1&3&6\\\end{matrix})(\begin{matrix}2&5\\\end{matrix})$

由此可见，$\tau$虽不是轮换，但它可分解成是轮换的乘积。这为解决置换分解问题提供了一个思路。下面考虑对任意置换的轮换分解问题。首先给从下列定义：  

【定义7.15】设$\pi=(i_{1},i_{2},\cdots,i_{t})$和$\tau=(j_{1},j_{2},\cdots,j_{s})$都是轮换，如果$\pi$和$\cdot_{\tau}$不含相同的元素，则称$\pi$与$\tau$是不相交的。  

例如，集合$A=\{1,\!2,\!3,\!4,\!5,\!6\}$上的两个轮换(1,2,5)和(3,4,6)之间是不相交的，而轮换(1,2,5)和(2,4,6)之间则是相交的。  

下面给出对任意置换的轮换分解定理：  

【定理7.10】（轮换分解定理）任一$ n$元置换都可写成若干个不相交轮换的乘积。  



## § 7.5 函数关系的应用  

### 7.5.1 哈希查找问题  

在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  

例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  

（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  

（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  

分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  

表 7-7 
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  

![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  

在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  

（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  

$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  

对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  

$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  

（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  

表7-8  平方取中法 
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  

（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  

哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  

在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  

在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。  

### 7.5.2 宽带分配问题  

随着互联网上语音视频业务的飞速增长，宽带成了影响服务质量的主要因素。一般来说，用户使用的宽带分成两部分：静态宽带和动态宽带。静态宽带是运营商承诺的最小宽带，已经预留给每个用户；动态宽带被所有的用户共享，根据需求进行分配。语音视频业务服务过程一般分成三步：建立连接、进行语音视频传输、结束服务。对于已经建立连接并正在进行传输的服务，运营商应该保证其所需要的宽带。而在连接阶段，如果所有客户申请的宽带总量超过运营商所提供的宽带时，则进行宽带分配。用户的优先级通常他可使用的最大宽带与已占有的宽带之比，需求量越大，被满足的宽带越小，则优先级越高。  

假设已知每一项业务所申请的宽带大小，在保证分配的宽带之和不超过网络总宽带的条件下，如何选择业务，以使得业务优先级收益（即所有业务的优先级之和）达到最大？  

可以用集合与函数对这个问题进行建模。设用户集合是$\{1,2,\cdots,n\}$，用户$𝑖$提出了$t_{i}$个宽带申请，其第$𝑗$个申请的宽带是$r(i,j)$，这里$i=1,\!2,\cdots,n,\:\:\:\mathrm{j}=1,\!2,\cdots,t_{i}.$。假设此刻运营商能提供的动态宽带总量是$B$用户$i$已使用的宽带为$C_{i j}$，可使用的最大宽带为，那么$C_{i j}\leq M_{i j}$。用户$i$的优先级函数记作$P(i,j)$，其中：$P(i,j)=C_{i j}/M_{i j}$。  

用函数$X(i,j)$表示对用户$i$的第𝑗个申请的分配结果$X(i,j)=1$表示分配$X(i,j)=0$表示不分配，那么问题的优化目标是使得下述函数，即优先级利益：  

$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot P(i,j)\quad\text{(7-9)}
$$

达到最大，同时满足不超过总宽带的约束条件，即：  

$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot r(i,j)\leq B\quad\text{(7-10)}
$$

这是个典型的组合优化问题，$n$个用户总计有$t_{1}+t_{2}+\cdots+t_{n}=m$个宽带请求，分别标号为${1,2,\cdots,m}$。在考虑前$n$项宽带请求$k=(1,\!2,\cdots,m)$，总宽带限制为$l(l=1,\!2,\cdots,B)$的情况下，设最佳分配的优先级收益为$v(k,l)$。  

如果此时把宽带分配给第$k$项业务（可能是第$𝑖$个用户的第$𝑗$个申请），该业务所需宽带是$r(k)$（在$r(k)=r(i,j)\leq l$的情况下），优先级收益是$P(k)=P(i,j)$。那么，剩下的宽带是$l-$$r(k)$。这些宽带将在${1,2,\cdots,k-1}$项业务中分配，所得到的优先级收益将是$v(k-1,l-r(k))$，因此总的优先级收益是$v(k-1,l-r(k)+P(k))\mathrm{v}$。相反，如果不把宽带分配给第$k$项业务，那么全部宽带𝑙将在${1,2,\cdots,k-1}$项业务中分配，总收益为$v(k-1,l)$为了使得优先级的总收益最大，只要在上述两个收益中选择最大的即可。  

上述分析可以总结成下面的递推公式，即$\forall k(0\leq k\leq m),\forall l(0\leq l\leq B)$，有  

$v(k,l)$  

![](images/ca1bba9e9c93f3e9595cc988da9323614b05bd9b58074b31eaf8aa4a7e6c05f3.jpg)  

根据这个公式：  

第一步先计算$k=1,\mathsf{l}=1,2,\cdots,B$的$v(1,l)$值，并把它们存到一个表中；  

第二步计算$k=2,\mathsf{l}=1,2,\cdots,B$的$v(2,l)$值，再把得到的值存到这个表中。  

每步计算若用到的较小的$v(k,l)$值，就到表中去取。照此做下去，直到计算出$k=m,l=$${1,2,\cdots,B}$的$v(m,l)$值为止，其中的$v(m,B)$就是最佳分配的优化函数值，即最大优先级收益。  

上述计算完成后，再根据$v(m,B)$的值逐步向前追溯，就可以找到最佳分配方案。先看$v(m,B)$是等于$v(m-1,B)$，还是等于$v\bigl(m-1,B-r(m)\bigr)+P(m)\,?$若等于前者，则没有选择第$m$项业务；若等于后者，则选择了第$m$项业务。然后根据剩下的部分是$v(m-1,B)$还是$v\big(m-1,B-r(m)\big)$来追溯第$m-1$项业务是否被选到。照此下去，直到$m$项业务都考察到，就得到问题的解。如果在计算每一项$v(k,l)$的时刻就把是否选择第$k$项业务记录下来，则就可以省略追溯过程，只需查一下全部记录，就能得到了问题的解。  

