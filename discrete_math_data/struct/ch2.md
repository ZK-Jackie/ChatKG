# 第二章  整数与算法设计基础

整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  

综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。  

## $\S\ 2.1$ 整数的基本知识

本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。  

### 2.1.1 整数与整数除法

在第一章，我们得到自然数和自然数集的定义。在自然数集中加入每个非零元素的相反数就得到整数集合，整数集中每个元素称为整数。也就是说，对于整数集合$z$，有：  

$$
Z\!=\!\{\cdots\!,\,\!-4,\,\!-3,\,\!-2,\,\!-1,\,0,\,1,\,2,\,3,\,4,\,\cdots\}
$$

对于整数，我们主要考察其除法运算，包括整除和带余除法，由此可以得到倍数与因子、素数与合数、商与余数的相关概念和性质。  

首先在整数及其乘法运算基础上，考察整除的概念与性质。  

【定义2.1】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，若存在整数$q$，满足$b=a\cdot q($其中“∙”表示普通数乘运算，通常将其省略)，则称$\pmb{a}$ 能整除$\pmb{b}$，或$\pmb{b}$ 能被$\pmb{a}$ 整除，记为a|b。此时，又称$a$ 是$b$ 的因子或$b$ 是$a$ 的倍数。若不存在任何整数$q$，满足$b=a q$，则称$\pmb{a}$ 不能整除$\pmb{b}$，或$\pmb{b}$ 不能被$\pmb{a}$ 整除，记为$a\nmid b$。  

例如：5|25，13 ∤120，7|49，13|0，$^{-3}\vert$-12，9 ∤−56；8 的因子有$\pm1$，$\pm2$，$\pm4$和$\pm8$，7的因子有$\pm1$和$\pm7$。显然，对于任意一个给定的整数$a$，它至少能够被$\pm1$或$\pm n$整除。因此，这四个是$a$ 的因子，称其为$a$ 的平凡因子。$a$ 的其它因子称为非平凡因子。  

【定义2.2】对于任意一个给定的非零整数$a$，若$a\ne\pm1$且没有非平凡因子，则称$a$ 为素数或质数；否则称$a$ 为合数。  

从一定意义上讲，素数是构成整数的基本要素，在整数理论中具有极其重要的地位。若非特别说明，我们所说的素数都是指正素数。2 是第一个正素数，其后还有3, 5, 7, 11,…, 等等。我们还会后续相关内容中详细讨论素数的性质与应用。  

例如，整数2, 3, 5, 7, 11, 13 都是素数，而4, 10, 16, 21 都不是素数。  

对于一个不是很大的整数，显然可用一个比较简单的方法来判定一个大于2 的正整数$b$是否为素数：用从2 到$b-1$的每一个整数去除$b$，如果这些整数都不是$b$ 的因子，那么$b$是素数。注意到：若$a k=b$，则$a$ 或$k$ 小于或等于$\sqrt{b}$。由此可知，如果$b$ 不是素数，那么它必有一个因子$k$ 满足不等式$1<k\leq{\sqrt{b}}$ 。因此，为得到更高的效率，只需在这个范围里检验因子。同样，如果$b$ 有一偶数因子，那么2 一定是该因子的一个因子。因此，在通过2 的整除性检验后，可以跳过所有偶数。要判断一个很大的整数是否为素数则不是一件容易的事情，我们将在本章后续的相关部分具体介绍整数集合中大素数的分布和查找知识。  

整数的整除运算具有如下基本性质：  

【定理2.1】假设$a,b,c$ 是3 个任意给定的整数，则有：  

（1）$a|b$ 当且仅当$\pm a|\pm b$； 

（2）若$a|b,\ b|c$，则 $a|c$； 

（3）若$;b|a_{i},\;\;i=1,\;\;2,\;\;\cdots,\;\;k$，则 $b|a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}$，此处 $x_{i}(i=1,\ \ 2$，$\cdots,\;\;k)$也是任意的整数； 

（4）若$b|a$，则 $b p|a p$，此处$p$ 是任意非零整数； 

（5）若$b|a$，$a\neq0$，则 $|b|\leq|a|$； 下面仅证明（3）和（5），其余性质的证明与此类似，读者可自行给出。 

【证明】（3）因为$b|a_{i}$，所以存在整数$p_{i}$使得$\mathbf{\nabla}a_{i}=b p_{i}$，$i=1$，2，⋯，$k$，故有： $a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}=b p_{1}x_{1}+b p_{2}x_{2}+\cdots+b p_{k}x_{k}$ $=b\ \left(p_{1}x_{1}+p_{2}x_{2}+\cdots+p_{k}x_{k}\right)$ 其中$p_{1}x_{1}+p_{2}x_{2}+\cdots+p_{k}x_{k}$显然是整数，故有：$b|a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}\,.$。  

（5）因为，故存在整数，使得。从而有：，又由1 知： $|b|\leq|a|$ 。  

整数的定义和性质虽然比较简单，却是数论的基础，具有非常广泛的应用。  

【例题2.1】求证：若$b$ 是奇数，则8$\left|(b^{2}-1)\right|$  

【证明】设$b=2k+1$，则  

$$
b^{2}-1=(2k-1)^{2}-1=4k(k+1)\,\circ
$$

在$k$ 和$k+1$中必有一个是偶数，故有$\quad3|(b^{2}-1)\quad$。  

【例题2.2】证明方程$x_{1}^{2}+x_{2}^{2}+x_{3}^{2}=1999$无整数解。

【证明】若$x_{1}$，$x_{2}$，$x_{3}$都是奇数，则根据上个例题，存在整数$\cdot A_{1}$，$A_{2}$，$A_{3}$，使得：  
$$
x_{1}^{2}=8A_{1}+1,\;\;x_{2}^{2}=8A_{2}+1,\;\;x_{3}^{2}=8A_{3}+1
$$

从而有：$x_{1}^{2}+x_{2}^{2}+x_{3}^{2}=8(A_{1}+A_{2}+A_{3})+3$  

但1999 除以8 的余数是7，矛盾！因此，$x_{1},\;\;x_{2}$，$x_{3}$不可能都是奇数。又由于$x_{1}$，$x_{2}$，$x_{3}$的平方和为奇数，故它们当中只能有一个为奇数。不妨设$x_{1}$为奇数，$x_{2}$，$x_{3}$为偶数，则存在整数$B_{1}$，$B_{2}$，$B_{3}$，使得$x_{1}^{2}=8B_{1}+1$，$x_{2}^{2}=8B_{2}+r$，$x_{3}^{2}=8B_{3}+s$，其中$r$ 和$s$ 是整数且只能取值0 或4（因为$x_{2}^{2}$，$x_{3}^{2}$是4 的倍数）。故有：  

$$
x_{1}^{2}+x_{2}^{2}+x_{3}^{2}=8(A_{1}+A_{2}+A_{3})+1+r+s
$$

此时，$x_{1}^{2}+x_{2}^{2}+x_{3}^{2}$除以8 余数只能是1 或5，但1999 被除以8 的余数是7，此时$\cdot_{x_{1}}$$x_{2}$，$x_{3}$也不能满足方程$x_{1}^{2}+x_{2}^{2}+x_{3}^{2}=1999.$。  

综上所述， $x_{1}^{2}+x_{2}^{2}+x_{3}^{2}=19991$ 方程无解。  

根据整除的定义，我们知道任意两个整数之间并不一定满足整除关系。为使整数能够正常进行除法运算，必须对整除概念进行推广。事实上，对于任意两个整数，虽然它们之间不一定具有整除关系，但总存在如下关系：  

【定理2.2】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，则必然存在唯一确定的一对整数$q$ 和$r$，满足下列等式：  

$$
b=a q+r,\;\;0\leq r<|a|	\tag{2-1}
$$

此时称整数$a$ 为除数、$b$ 为被除数、$q$为$b$ 除以$a$的商、$r$为$b$ 除以$a$ 的余数。

【证明】（存在性）若$b|a$，则存在整数$q$ 使$a=b q$，此时取$r=0$，等式成立。若$b\nmid a$，考虑集合：$A=\left\{a+k b{\mathrm{:~}}k\in Z\right\}$，其中𝑍为整数集。  

令集合$A$ 中所有正整数组成的集合为$T$，则由自然数子集的最小数存在原理知：$T$ 中必然存在最小正整数，设其为$r=a+k_{0}b$（其中$k_{0}$是正整数），则必有：$0<r<|b|$。  

否则，如果$.r\geq|b|$；那么因为$b\nmid a$，所以$b\nmid r$，故$r\neq|b|$。于是有$\cdot_{\boldsymbol{r}}>\vert b\vert$，即有：  

$$
a+k_{0}b>|b|,\;\;a+k_{0}b-|b|>0
$$

此时在集合$T$中，又有正整数$a+k_{0}b-|b|<r$，这与$r$的最小性矛盾。因此，式$0<r<|b|$必定成立。现取$q=-k_{0}$，则等式(2-1)成立，存在性得证。（唯一性）假设有两对整数$q^{\prime}$，$r^{\prime}$与$q"$，$r^{\prime\prime}$都使等式成立，即有：  

$$
a=q^{\prime}b+r^{\prime},\;\;0\leq r^{\prime}<|n b|;\;\;a=q^{\prime\prime}b+r^{\prime\prime},\;\;0\leq r^{\prime\prime}<|b|
$$

故有$(q^{\prime}-q^{\prime\prime})b=r^{\prime}-r^{\prime\prime}$，即有$b|(r^{\prime}-r^{\prime\prime})$。  

而$|r^{\prime}-r^{\prime\prime}|<|b|$，则必有$r^{\prime}-r^{\prime\prime}=0$。否则，根据定理2.1 中的（5）知，必有$|b|<|r^{\prime}-$$r^{\prime\prime}$，矛盾！由此可得：$q^{\prime\prime}-q^{\prime}=0$，即$q^{\prime\prime}=q^{\prime}$。唯一性得证。证毕。  

从上述定理的证明过程可以看出，整除是带余除法中余数等于0 的情形。因此，带余除法可以看成是对整除的一种推广。事实上，还可通过带余除法的概念来定义和理解整除的概念，即$a$ 能够整除$b$ 的当且仅当$b$ 除以$a$的余数为0。  

### 2.1.2 整数的因数分解

对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。  

#### 一、公因数与公倍数

假设$a$ 和$b$ 是任意给定的两个整数，如果$b$ 能够整除$a$，那么$b$ 就是$a$的一个因数、$a$就是$b$ 的一个倍数，此时可分别从因数和倍数这两个角度对整数进行考察。  

具体地说，如果$b$ 也是另外一个整数$c$ 的因数，则$b$ 就反映出$a$ 和$c$ 的某种共同特征，或者说整数$a$ 和$c$ 具有一个相同的构件$b$，通常将其称为$a$ 与$c$的公因数。同样，如果整数$a$ 也是另外一个整数$s$ 的倍数，则$b$ 和$s$ 就有一个共同的倍数$a$，通常称之为公倍数。公因数和公倍数分别从两个不同角度考察任意两个整数之间的联系，具体定义如下：  

【定义2.3】假设$i$ 和$j$是任意两个整数，如果整数$b$ 能够同时整除$i$和$j$，则称$b$ 是$i$和$j$ 的一个公因数，如果$i$ 和$j$都能够整除整数$a$，则称$a$ 是$i$ 和$j$的一个公倍数。  

自然数1 可以整除任意整数，因此对于任意两个整数，它们的公因数总是存在的。公因数表达的是两个整数的共同部分，通常需要考察两个整数之间的共同部分最大值能达到多少，故有所谓最大公因数的概念。同样，对于任意两个整数，这两个整数的乘积就是它们的公倍数，因此，公倍数总是存在的，需要着重考察的通常式公倍数的最小值，因而有最小公倍数的概念。最大公因数和最小公倍数的具体定义如下：  

【定义2.4】假设$a$ 和$b$ 是任意给定的两个整数，$a$ 和$b$ 的所有公因数中最大的那个整数称为$a$ 和$b$ 的最大公因数，记为$\operatorname*{gcd}(a,b)$或$(a,b)$，$a$ 和$b$ 的所有公倍数中最小的那个整数称为$a$ 和$b$ 的最小公倍数，记为$\operatorname{lcm}(a,b)$或$[a,b]$。  

例如： $\operatorname*{gcd}(5,7)=1$$\operatorname*{gcd}(15,21)=3;\;\;\operatorname*{gcd}(132,240)=12;$； $\operatorname{lcm}(5,7)=35;\ \operatorname{lcm}(15,21)=105;\ \operatorname{lcm}(132,240)=2640$ 

规定g$\mathtt{c d}(0,0)=0$。易知若$a$，$b$不全为零，则$\operatorname*{gcd}(a,\ b)>0$。  

【定理2.3】假设$a$ 和$b$ 是任意给定的两个整数，则有：  

$$
a\cdot b=\left(a,b\right)\cdot\ \left[a,b\right]\tag{2-2}
$$

【证明】设$a$ 和$b$ 的最大公因数为$X$，则$a$和$b$ 可以表示为：

​							$mX,nX（其中m,n互质)$

因此，$m X,n X$的最小公倍数为𝑚𝑛𝑋。显然有：  
$$
X\cdot(m n X)=(m X)\cdot(n X)
$$

即有：两个数的乘积等于最大公因数与最小公倍数的乘积。 

例如：根据$\operatorname*{gcd}(15{,}21)=3$和l$\mathsf{I c m}(15{,}21)=105$，可得到：  
$$
15{\cdot}21{=}\ \mathrm{gcd}(15,21){\cdot}\ \ \mathrm{lcm}(15,21){=}\ 3{\cdot}105
$$

【定理2.4】假设$a$ 和$b$ 是任意给定的两个整数，如果$a$ 和$b$ 都能整除整数$k$，则其最小公倍数$[a,b]$也能整除$k$。  

【证明】记$M{=}[a,b]$，设$k=M q+r$，$0\leq r\leq M$  

由$a|k,\ \ a|M$，及$r=k-M q$，可推出$a|r$；同理，有$b|r$；即$r$是$a$，$b$ 的公倍数。由最小公倍数的定义，有$r=0$，即$M|k$，即$a$ 和$b$ 的最小公倍数$[a,b]$能整除$k$。证毕！

【例题2.3】求证6 和9 的最小公倍数可以整除36  

【解】因为$36=6\cdot6=4\cdot9$，所以6 和9 都可以整除36，6 和9 的最小公倍数为1818 也可以整除36，即[6, 9]可以整除36。证毕！ 

显然，可以将公因数和公倍数的相关直接概念推广到如下多个整数的情形：  

【定义2.5】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$s$ 是其中每个整数的因数，则称$t$是$a_{1},a_{2},\cdots,a_{k}$的一个公因数。对于给定的整数$a_{1},a_{2},\cdots,a_{k}$，它们的公因数只有有限多个，其中最大的那个公因数称为$a_{1},a_{2},\cdots,a_{k}$的最大公因数，记为gc$\mathfrak{d}(a_{1},a_{2},\cdots,a_{k}).$。  

【定义2.6】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$t$是其中每个整数的倍数，则称$t$ 是$a_{1},a_{2},\cdots,a_{k}$的一个公倍数。$a_{1},a_{2},\cdots,a_{k}$的所有公倍数中数值最小的那个公倍数，称为$a_{1},a_{2},\cdots,a_{k}$的最小公倍数，记为$\operatorname{lcm}(a_{1},a_{2},\cdots,a_{k})$。  

【例题2.4】24 和36 的最大公因数是什么？ 

 17 和22 的最大公因数是什么？  

【解】24 和36 的正公因数是1，2，3，4，6，12，所以$\operatorname*{gcd}(24,36)=12$ 

 17 和22 除1 以外没有正公因数，因此有：$\operatorname*{gcd}(12,22)=1$。 

【例题2.5】求6, 18 和12的最小公倍数。  

【解】36 可以同时整除6, 18 和12，所以36 是它们的一个公倍数，同理72,144，⋯也是6,18 和12的公倍数，36是6, 18 和12 的所有公倍数中数值最小的公倍数，故有：  

$$
\operatorname{lcm}(6,18,12)=36
$$

即 6,18  和 12 的最小公倍数为 36 。 

下面定理是最大公因数的一个重要定理，它刻画了最大公因数在带余除法中的不变性质，为最大公因数的构造算法——辗转相除法提供了坚实的理论基础。  

【定理2.5】假设$a$ 和$b$ 是任意给定的两个整数，若有$b=a q+r$，$0\leq|r|<a$，则必有：$\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r).$。  

【证明】设$k$ 是$a$ 与$b$ 的任一公因数，$k|a,\ k|b$，由整除运算的基本性质（3）知，$k$是$b-a q$的因数，因而$k$ 是$a$ 与$r$ 的公因数；同法可证$a,~\boldsymbol r$的任一因数也是$a$，$b$的公因数，于是 $b$ ， $a$  与 $a,\ r$ 有相同的公因数，立得结论 $\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r)$ 。  

例如，由$22=4\cdot5+2$，可知$\operatorname*{gcd}(22,4)=\operatorname*{gcd}4,2)=2.$

下面介绍求两个整数最大公因数的算法——辗转相除法：

设$a,~b$ 是任意两个正整数，由带余除法，可以得到一系列整式。  
$$
b=a q_{1}+r_{1},\;\;0<r_{1}<b,
$$

$$
a=r_{1}q_{2}+r_{2},\;\;0<r_{2}<r_{1},
$$

$$
r_{n-2}=r_{n-1}q_{n}+r_{n},\;\;0<r_{n}<r_{n-1},
$$

$$
r_{n-1}=r_{n}q_{n+1}+r_{n+1},\;\;r_{n+1}=0\,,
$$

由定理2.5 知：  

$$
\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r_{2})=\cdots=\operatorname*{gcd}(r_{n},r_{n+1})=r_{n}
$$

因此，最大公因数就是除法序列中最后一个非零余数。这就是计算最大公因数辗转相除算法。它是由我国古代数学家创造，西方称其为欧几里得算法。  

【例题2.6】用欧几里得算法求gcd(126, 27)以及$x,\ y$，使得：  

$$
126x+27y=\operatorname*{gcd}(126,27)
$$

【解】用辗转相除法依次得到：  

$$
126=27\cdot4+8,\qquad27=18\cdot1+9,\qquad18=9\cdot2
$$

故有$\operatorname*{gcd}(126,27)=9$。现倒推求整数$x$，$y$  

$$
9=27-18\cdot1=27-1\cdot(126-27\cdot4)=-1\cdot126+27\cdot5
$$

因此，$x=-1,\ y=5$，满足$126x+27y=\operatorname*{gcd}(126,27)$。  

【例题2.7】用欧几里得算法求414 和662 的最大公约数。  

【解】辗转使用整除算法给出：  

$$
662=414\cdot1+248;\;\;414=248\cdot1+166;
$$

$$
248=166\cdot1+82;\;\;166=82\cdot2+2;\;\;82=2\cdot41
$$

因此$\operatorname*{gcd}\!\left(414,\ 662\right)=2$，因为2 是最后一个非零余数。

使用辗转相除算法可以证明如下关于最大公因数的线性结构性质：

【定理2.6】假设$a$ 和$b$ 是任意两个整数，则必然存在两个整数$\cdot k_{1}$和$k_{2}$，满足：  
$$
\operatorname*{gcd}(b,a)=k_{1}\cdot b+k_{2}\cdot a\tag{2-3}
$$

【证明】记$b=r_{0},\;\;a=r_{1}$，依据辗转相除法可写成  

$$
r_{i}=r_{i+1}q_{i+1}+r_{i+2},~i=0,~1,~~\cdots,~n-2,
$$

$$
r_{n-1}=r_{n}q_{n+1}
$$

其中$\operatorname*{gcd}(b,a)=\ r_{n}$。可将上式改写成：  

$$
r_{i}=r_{i-2}q_{i-1}+r_{i-1},~i=2,~3,~\cdots,~n
$$

从后向前逐个回代，就将$r_{n}$表成$b$ 与$a$ 的线性组合。  

【例题2.8】用辗转相除法求252 与198 最大公因数$d$，并将其表示成252 与198 的线性组合。  

【解】做辗转相除法：  

$$
252=198\cdot1+54;\;\;198=54\cdot3+36;
$$

$$
54=36\cdot1+18;\;\;36=18\cdot2
$$

故有：$\operatorname*{gcd}(252{,}198)=18$  

从后面向前逐个回代，有：  

$$
18=54-36\cdot1=54-(198-3\cdot54)
$$

$$
=54\cdot4-198=(252-198)\cdot4-198=
$$

$252\cdot4-198\cdot5$  

上述定理表明，整数$a$ 和$b$ 的最大公因数可以表示为它们的一个线性组合。这就给出了最大公因式一种具体表达形式，这种表达形式对于考察最大公因数的性质具有非常重要的作用。例如，使用上述线性组合表达式，可得到最大公因数下述性质：  

【定理2.7】假设$a$ 和$b$ 是任意给定的两个整数，如果$d$ 是$a$ 和$b$ 的任意一个公因数，则$d$一定能整除$\operatorname*{gcd}(a,b)$。  

【证明】由上一定理2.6 可知存在整数$\cdot k_{1}$和$k_{2}$，使得$\operatorname*{gcd}(a,b)=k_{1}\cdot a+k_{2}\cdot b$。因为$d$是$a,~b$ 的任意一个公因数，所以$d|a,\ d|b$，故有： $d|(k_{1}\cdot a+k_{2}\cdot b)$，即$d$ 一定能够整除$\operatorname*{gcd}(a,b)$  。  

上述定理表明，最大公因数不仅是最大的公因数，而且是所有公因数的倍数。

例如，我们知道$\operatorname*{gcd}(56,24)=8$，因此有$m=-1$，$n=2$使得：  
$$
8=56\cdot(-1)+24\cdot2
$$

事实上，56 与24 有正的公因数1, 2, 4, 8，而g$\operatorname{cd}(56,24)=8$则是其他公因数的倍数。  

####  二、互素的概念与性质

从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  

【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  

$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  

【例题2.9】小于12 的哪些正整数与12 互素？

【解】12 与1, 3, 5, 7, 11 是两两互素的，而：  

$\operatorname*{gcd}(12,2)=2;\;\;\operatorname*{gcd}(12,4)=4;\;\;\operatorname*{gcd}(12,6)=6;$      gcd(12,8) = 4 $\operatorname*{gcd}(12,8)=4;\;\;\operatorname*{gcd}(12,9)=3;$ ； $\operatorname*{gcd}(12,10)=2$ 。  

【例题2.10】判断整数10, 17 和21 是否两两互素，整数10, 19 和24 是否两两互素。  

【解】由于g$\mathfrak{K d}(10,17)=1$，$\operatorname*{gcd}(10,21)=1$ 和$\operatorname*{gcd}(17,21)=1$，故10，17 和21 是两两互素。由于$\operatorname*{gcd}(10,24)=2>1$，所以10，19 和24 不是两两互素。  

根据互素的定义，不难得到有关互素整数的下列性质：

【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  

【证明】（反证法）假定$\operatorname*{gcd}(a,b)=d$，且$s,~t$不是互质的，不妨设$\operatorname*{gcd}(s,t)=m$，$m>$1，故有：  

$$
s=m l;\ t=m n
$$

从而由$a=d x,\ b=d y$，得到：  

$$
d=a s+b t=d x m l+d y m n=d m(x l+y n)
$$

即md 能够整除$d$，这与$m{>}1$ 矛盾。因此$m{=}1$，即$s$ 与$t$互质。证毕！  

【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  

【证明】由题意知，成立：  

$$
1=a s_{1}+b_{1}t_{1},\;\;1=a s_{2}+b_{2}t_{2},\;\;\cdots,\;\;1=a s_{n}+b_{n}t_{n}
$$

将上述$n$ 个等式作用两边分别相乘，在得到的等式中，左边是1，右边只有一个含$b_{1}b_{2}\cdots b_{n}$的项不含因数$a$。故可将等式写成$1=a s+b_{1}b_{2}\cdots b_{n}t$，则$a$ 必与$b_{1}b_{2}\cdots b_{n}$互素.否  则$a$ 与$b_{1}b_{2}\cdots b_{n}$有大于1 的公因数$m$，得到出$m|1$，矛盾！  

【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立： 

（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$； 

（2）若$b|c$且$a|c$，则有$a b|c$。  

【证明】（1）若$\operatorname*{gcd}(a,b)=1$，则存在整数$x$ 与$y$，使得$a x+b y=1$。故有：  

$$
a c x+b c y=c
$$

再由$b|a c$可知$_{b|c}$。结论（1）得证。  

（2）若g$\mathfrak{c d}(a,b)=1$，则存在整数$x,~y$，成立$a x+b y=1$，进而有：  

$$
a c x+b c y=c
$$

由$b|c$与$a|c$得到$a b|a c$与$a b|b c$，再由式上式可得$a b|c$。结论（2）得证。 

【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$  

【证明】若$\operatorname*{gcd}(a,b)=1$，则存在整数$x$ 和$y$，使得$a x+b y=1$，故有$a k x+b k y=k$下面往证：$a$ 与$k$ 的公因数集合等于$a$ 与$n k$的公因数集合。  

设$d$是$a$ 与$n k$的一个公因数，则$d|m,\ d|n k$，由$m k x+n k y=k$得到，$d|k$，即$d$是$a$与$k$ 的公因数。另一方面，若$d$是$a$ 与$k$ 的公因数，则它也是$a$ 与$n k$的公因数。因此，$a$ 与$k$的公因数的集合，就是$a$ 与$b k$的公因数的集合，因而它们的最大者也相同，即$\operatorname*{gcd}(m,n k)=$$\operatorname*{gcd}(m,k)$  。证毕！

【例题2.11】设$a|c,\ b|c$，且$\operatorname*{gcd}(a,b)=1$，则$a b|c$

【证明】由$\operatorname*{gcd}(a,b)=1$知存在整数$x$ 和$y$，使得  
$$
x a+y b=1
$$

两边同时乘以$c$，得：$c x a+c y b=c.$.又由$a|x a,\ b|c$得$a b|c x a$。同理有：$a b|c y a$  

故有：$a b|c x a+c y b$，即$a b|c$。  

#### 三、算术基本定理

对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  

我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  

【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  

【证明】当$a=2$时，结论显然成立。假设对于$2\leq a\leq k$，成立$a=p_{1}p_{2}\cdots p_{b}$，下面往证该式对于$a=k+1$也成立：  

如果$k+1$是素数，则显然成立$a=p_{1}p_{2}\cdots p_{b}$。  

如果$k+1$是合数，则存在素数$\cdot p$与整数$d$，使得$k+1=p d$。由于$2\leq d\leq k$，由归纳假定知存在素数$\cdot q_{1},q_{2},\cdots,q_{i}$，使得$d{=}q_{1}q_{2}\cdots q_{i}$，从而$k+1=p q_{1}q_{2}\cdots q_{i}$。证毕！

[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$

其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。

【证明】由定理2.12，任何大于1 的正整数$a$ 均可表示成$ a=p_{1}p_{2}\cdots p_{m}$的形式，而

​              $ a=p_{1}p_{2}\cdots p_{m}$ 与$$ a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}$$

 的表示显然是等价的。因此，只需证明式(2-4)的唯一性。

假设$\cdot p_{i}(1\leq i\leq k)$与$q_{j}(1\leq j\leq l)$都是素数，  
$$
p_{1}\leq p_{2}\leq\cdots\leq p_{k},\;\;q_{1}\leq q_{2}\leq\cdots\leq q_{l}
$$

且  

$$
a=p_{1}p_{2}\cdots p_{k}=q_{1}q_{2}\cdots q_{l}\tag{2-5}
$$

则由素数的性质知：必有某个 $q_{j}(1\leq j\leq l)$ ，使得 $\cdot p_{1}|q_{j}$ ，所以 $p_{1}=q_{j}$ ，又有某个 $p_{i}(1\leq i\leq$ $k_{\scriptscriptstyle2}$)，使得$q_{1}|p_{i}$，所以$q_{1}=p_{i}$。故有：$p_{1}=q_{1}$，从而由式(2-5)得到：  

$$
p_{2}\cdots p_{k}=q_{2}\cdots q_{l}
$$

重复上一过程，即可得到$k=l$，$p_{i}=q_{j}$，$(1\leq i\leq k)$证毕。

上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  

【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  

$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$

是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  

【解】  

$$
\begin{array}{r l}{51480=2^{3}\cdot6435=2^{3}\cdot5\cdot1287}\\ {=\ 2^{3}\cdot5\cdot3^{2}\cdot143}{{}=2^{3}\cdot3^{2}\cdot5\cdot11\cdot13\quad}\end{array}
$$

【例题2.13】写出10 个连续的正整数，使他们都是合数。  

【解$111!+2$，$11!+3$，⋯，11！$+11$。因为2$\lvert(11\!\ +2)$，3|(11！+3)，⋯，11|(11！+11)故它们是 10  个连续的合数。

整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  

【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  

$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$

其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  

$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$

$$
 {\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$

【证明】略。

【例题2.14】$2^{3}3^{5}7^{2}$和$2^{4}3^{3}$的最小公倍数是什么？  

【解】依题意，有：  

$$
\operatorname{lcm}(2^{3}3^{5}7^{2},2^{4}3^{3})=2^{m a x(3,4)}3^{m a x(5,3)}7^{m a x(2,0)}=2^{4}3^{5}7^{2}
$$

即$2^{3}3^{5}7^{2}$和$2^{4}3^{3}$的最小公倍数是$2^{4}3^{5}7^{2}$。

下面的定理给出了两个整数的最大公约数和最小公倍数之间的关系：  

【例题2.15】求132 与240 的最大公因数与最小公倍数。  

【解】对132 与240 作素因子分解  

$$
132=2^{2}\times3\times11;\ \ 240=2^{4}\times3\times5
$$

故有：  

$$
\operatorname*{gcd}(132,240)=2^{3}\times3\times5^{0}\times11^{0}=12
$$

$$
\operatorname{lcm}(132,240)=2^{4}\times3^{1}\times5^{1}\times11^{1}=
$$

2640      

### 2.1.3 素数的性质与查找  

通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  

素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  

【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  

【证明】（1）若$a$ 为素数，则显然$p$ 与$a$ 互素。  

（2）若$a$ 不是素数，由定理2.12 可知，$a$可写成若干素数的积，即$a=p_{1}p_{2}\cdots p_{m}$。若$p$  等于 $a$  的某个素因子，则 $p$  能整除 $a$ ；否则若 $p\neq p_{i},1\leq i\leq m$ ，则 $p$ 与 $a$ 互素。  

综上所述，定理得证。  

可以通过上述定理证明下面结论：  

【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  

【证明】用反证法。若质数$.p|a b$，则必有$\cdot_{p\mid a}$或$_{p\mid b}$  

假设$p$ 不能整除$a$ 且$p$不能整除$b$，那么$p$ 也不能整除$a b$，这与$p|a b$矛盾，故假设不成立,必有$\cdot_{p\mid a}$或$p|b$。 

下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  

【定理2.17】正整数集合中的素数有无穷多个。

【证明】用反证法。假设只有$k$个素数，设它们是$p_{1},\ \ p_{2},\ \ \cdots p_{k}$。令：  
$$
M=p_{1}p_{2}\cdots p_{k}+1
$$

由前面的素数定理知，任何大于1 的正整数$b$，或为一素数，或可以写成若干素数的积。即 $M$ 有素因数 $\cdot p$ ，下面往证： $p\neq p_{i}$ ， $1\leq i\leq k$ ，从而得出矛盾。  

事实上，若有某个𝑖，$1\leq i\leq k$，使得$p=p_{i}$，则由：  

$$
p|M,\;\;M=p_{1}p_{2}\cdots p_{k}+1
$$

推出$p|1$，这是不可能的。因此在$.p_{1}$$\iota_{1},\ \,p_{2},\ \ \cdots p_{k}$之外还有一个素数$_p$，这与假设矛盾。因此素数不可能只有有限个。

下面进一步讨论有限正整数集合中素数的计数与分布情况：  

【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  

【证明】假定$q$ 不是素数，那么$q$ 有除1 外的最小正约数$q_{1}$，即$1<q_{1}<q$，但$q|a$，$q_{1}|q$，所以$q_{1}|a$，这与$q$ 的取法矛盾，故$q$ 是素数。  

当$a$是合数时，则$a=a_{1}q$，且$a_{1}>1$，否则$a$是素数。由于$\cdot q$是$a$的不等于1 的最小正因数，所以 $q\leq a_{1}$ ， $q^{2}\leq q a_{1}=a$ ，故 $q\leq{\sqrt{a}}$ 。 

【例题2.16】判断137 和157 是否是素数。  

【解】因为$\sqrt{137}$和$\sqrt{157}$都小于13，故只需检验它们是否小于13 的素因子即可。小于13 的素数有：  

2, 3, 5, 7, 11

易验证，2, 3, 4, 7, 11都不能整除137，故137 是素数。同理，157 也是素数。

使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  

首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  

【例题2.17】作50 以内的素数表。  

【解】先按从小到大的顺序写出1 到50 的所有整数，因为${\sqrt{50}}<8$，故只需划去2,3,5,7的所有倍数和1 即可，所剩下的数即是50 以内的所有素数。  

![](images/7bfbadc39ebb34d2c328181f25aca4cd698717fc4cbf3818daa23b08fb00f597.jpg)  

故小于50 的所有素数有2, 3, 5, 7, 11, 13, 17,19, 23,29, 31,37,41, 43,47。

【例题2.18】求证：若$a>1$，$a^{b}-1$ 是素数，则$a=2$，并且$b$ 是素数。  

【证明】若$a>2$，则由：  

$$
a^{b}-1=(a-1)(a^{b-1}+a^{b-2}+\cdots+1)
$$

可知$a^{b}-1$是合数。因此$a=2$  

​		若$b$ 是合数，则有：  

$$
b=x y,\;\;x>1,\;\;y>1
$$

于是由  

$$
2^{x y}-1\ =(2^{x}-1)(2^{x(y-1)}+2^{x(y-2)}+\cdots+1)
$$

以及$2^{x}-1>1$，可知$|2^{b}-1$是合数，这与$a^{b}-1$ 是素数相矛盾！  

因此，$2^{b}-1$是素数时，$b$ 必是素数。

由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。  

## $\S\ 2.2$ 同余算术及其应用

前面关于整数理论的讨论主要基于整数整除的概念与性质。由于整除是一个是整数之间一个比较强的约束关系，很多整数都不能满足，因此引入一种具有普适性的带余除法概念，将整数的整除归结为一种余数为0 的特殊带余除法。德国数学家高斯则是从带余除法的角度对整除的概念进行推广，引入同余的概念及相关算术。从带余除法的角度看，同余并非像整除那样要求余数一定为0，而只要求两个整数被某个除数做带余除法后得到的余数相等，这个约束显然比整除的约束宽松很多。同余算术是整理理论一个重要发展并构成初等数论的理论核心，它从在一种比整除约束更为宽松的条件下考察整数的运算及性质并得到很多非常精彩的数论成果，这些成果在整数加密算法设计等多个领域得到广泛应用。本节主要介绍同余算术的概念、性质与应用，具体包括同余关系及其运算、剩余系的概念与性质、同余方程与方程组的求解、若干经典的整数加密算法。  

### 2.2.1 同余关系及其运算

在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  

【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  

$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$

则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  

根据上述定义，不难证明下面关于模$_m$同余的判定定理：  

【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  

【证明】设$a({\bmod{\ m}})=k$，由$a$和$b$具有模$m$同余关系可得$b({\bmod{\ m}})=k$，又因为：$(a-b)(\bmod{\ m})=a(\bmod{\ m})-b(\bmod{\ m})=k-k=0$  

故有：$m|(a-b)$。反之，如果$m$能够整除$a-b$，则有：  

$$
(a-b)(\bmod{\ m})=a(\bmod{\ m})-b(\bmod{\ m})=0
$$

得到：$a({\bmod{\ m}})=b({\bmod{\ m}})$，故整数$^{.}a$和$b$具有模$_m$同余关系。定理得证。


$$
例如，23\equiv3(\mathrm{mod}\;\;10),\;\;4\equiv-4(\mathrm{mod}\;\;8),\;\;100\equiv1(\mathrm{mod}\;\;9),\;\;13\equiv1(\mathrm{mod}\;\;9)
$$

在现实生活中，时钟的钟点读数模12 同余或者模24 同余，分和秒读数模60 同余，星期几的读法则是模7 同余。  

【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  

当且仅当存在整数$k$，使得整除$a=b+k m$  

【证明】设$a\equiv b({\bmod{\ }}m)$，则$m|(a-b)$，即存在整数$k$，使得$k m=a-b$，即$a=b+$𝑘𝑚。反之如果存在整数$k$使$a=b+k m$，则$a-b=k m$，故$a\equiv b({\bmod{\ }}m)$。□  

下面定理表明了同余关系的保加性和保乘性：  

【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  

$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$

【证明】由$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$可知，存在整数$k_{1}$和$k_{2}$，满足：  

$$
a=b+k_{1}m;~~~~~c=d+k_{2}m
$$

故有：$a+c=(b+d)+(k_{1}+k_{2})m$，即有：  

$$
a+c\equiv(b+d)({\bmod{\ m}})
$$

同理可得：$a c=b d+(b k_{1}+d k_{1}+k_{1}k_{2}m)m$，即有：$a c\equiv b d({\bmod{\mod{\ m}}})$。证毕！ 

【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  

$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$

$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$

【证明】根据模$m$ 同余的定义，可得：  
$$
a\equiv(a\,\bmod\,m)(\bmod\,m);\ b\equiv(b\,\bmod\,m)(\bmod\,m)
$$

因此，由定理2.21 可得：  

$$
\begin{array}{r}{a+b\equiv((a\,\bmod\,m)+(b\,\bmod\,m))(\bmod\,m)}\\ {a b\equiv((a\,\bmod\,m)(b\,\bmod\,m))(\bmod\,m)}\end{array}
$$

证毕！

例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  

$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$

$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$

再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  

$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$

$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$

值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  

【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  

【证明】假设$c$ 与$m$ 的最大公因数为$d$，则由$a c\equiv b c({\bmod{\pmod{m}}})$有：$m|c(a-b)$。故存在$k$ 使得$c(a-b)=k m$。  

再由$(c,\ m)=d$，有：  

$$
(c/d)(a-b)=k m⁄d
$$

又因为$\left(c/d\,,\,\,\,m/d\right)=1$，故有$\displaystyle m⁄d|a-b$，即：  

$$
a\equiv b({\bmod{\ }}m⁄d)
$$

因为$c$ 与$m$ 互素，故$d=1$，即有：$a\equiv b({\bmod{\ }}m)$。证毕！ 

【例题2.19】根据上面的定理，由$4\equiv14({\bmod{\ }}10)$，$24\equiv44({\bmod{\ }}10)$，可知  
$$
4+24=28\equiv58=(14+44)(\mathrm{mod}\;\;10)
$$

由$4\equiv14(m o d\;\;10)$，$9\equiv-1(m o d\;\;10)$，知$36\equiv-14({\bmod{\mathrm{~}}}10)$。  

【例题2.20】设$p$ 是素数，$m$ 是整数，则由$m^{2}\equiv1(m o d\,\,\,p)$可以推出：$\          m\equiv1({\bmod{\ }}p) 或  m\equiv-1({\bmod{\ }}p)$  

【证明】由$m^{2}\equiv1({\bmod{\,}}\,p)$可知：$p|(m^{2}-1)$。 即有：$p|(m+1)(m-1)$  

由于$p$ 是素数，故必有$p|(m+1)$或$p|(m-1)$，即有：  

$$
m\equiv1({\bmod{\ }}p)\not\equiv m\equiv-1({\bmod{\ }}p)
$$

如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  

【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  

$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$

则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  

【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  

（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$

（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：  
$$
a\equiv b({\bmod{m}})
$$

【证明】（1）设$a$ 是任意整数，由带余除法，得到：  

$$
a=m q+r,\;\;0\leq r<m
$$

故$a$ 在同余类${\cal R}_{r}$中。又由$r$ 是由$a$ 唯一确定的，因此，$a$ 只能在$R_{r}$中。（2）设$a$，$b$ 是两个整数，并且都在$R_{r}$内，则有：  

$$
a=m q_{1}+r,\;\;b=m q_{2}+r
$$

故有$a\equiv b({\bmod{\ }}m)$  

反之，若有$a\equiv b({\bmod{\pmod{m}}})$, 则$a$，$b$必在某一个同余类${\bf\nabla}_{\perp}R_{r}$内，$0\leq r\leq m-1$。  

上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  

根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：

【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：  
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$

$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$

【例题2.21】写出 $Z_{6}$的全部元素以及$Z_{6}$上的加法表和乘法表。  

【解】$Z_{6}=\{[0],$, [1], [2], [3], [4], [5]}，其中： $[i]=\{6k+i|k\in Z,\,\,\,i=0,1,2,3,4,5\}$  

加法表和乘法如表2-1 和表2-2 所示。  

表2-1 加法表
![](images/a7f1e343ce8feaa4c73d18b4b1743ae87fb63e3d07130ac36040aaf083322bb6.jpg)  

表2-2 乘法表
![](images/dcab4fe24604b3807a6f7d3a890dfaea6837136a577601feed01e7a05fbfee28.jpg)  
【例题$2.221\ 3^{358}$的个位数是多少？  

【解】设$3^{358}$的个位数是$x$，则有：  

$$
3^{358}\equiv x({\bmod{\ }}10)
$$

由$3^{4}\equiv1(m o d\;\;10)$和整除性质知：  

$$
3^{358}=3^{4\times89+2}\equiv3^{2}\equiv9({\bmod{\ }}10)
$$

故 $3^{358}$ 的个位数是 9 。

【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  

对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  

【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  

因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。  

【例题2.23】写出模5 的一个完全剩余系、最小非负完全剩余系以及一个简化剩余系。  

【解】集合{0, 6, 7, 13,24}是模5 的一个完全剩余系，集合{0, 1, 2, 3, 4}是模5 的最小非负完全剩余系，{6,7, 13, 24}是模5 的一个简化剩余系。

【例题2.24】写出模8 的一个简化剩余系。  

【解】集合$\{9,-5,-3,-1\}$是模8 的一个简化剩余系，集合{1，3，5，7}也是模8 的一个简化剩余系，通常称之为最小非负简化剩余系。

### 2.2.2 同余方程与方程组

相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  

【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  

(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；

 (2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$； 

(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。 

【证明】（1）因为$\ \cdot a-a=0,\ m|0$，所以$a\equiv a({{\pmod{m}}}).$。 

（2）设$a\equiv b{{\pmod{m}}}$，则$m|(a-b)$，即存在整数$k$，使得$k m=a-b$。故有：

$-k m=b-a$ 

故有：$m|b-a$，即$b\equiv a({\bmod{\ m}})$。  

（3）设$a\equiv b{{\pmod{m}}}$，$b\equiv c{{\pmod{m}}}$，则存在整数$k$，𝑙，满足：  

$$
k m=a-b;\enspace l m=b-c
$$

因而有：  

$$
a-c=(a-b)+(b-c)=(k+l)m
$$

故$m|(a-c)$，即$a\equiv c(m o d\,\,\,m)$。

我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  

【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  

$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$

称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  

显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  

下面考察一次线性同余方程解的存在性：  

【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  

$$
a x\equiv b({\bmod{m}})
$$

有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  

【证明】因为$a x\equiv b({\bmod{\pmod{m}}})$等价于$\cdot m|(a x-b)$，故$x_{0}$是模余方程$a x\equiv b({\bmod{\ m}})$解的充要条件是存在整数$y$，使得$\cdot a x_{0}-m y=b$。  

令$d=\operatorname*{gcd}(a,m)$，如果$d|b$不成立，由$d|a,\ d|m$，知$d|a x-m y$。若方程有解，则与$d|b$矛盾。故$d|b$不成立时，方程无解。  

如果$d|b$，由最大公因子的求法知存在$x_{0},\ y_{0}$使得$a x_{0}-m y_{0}=b$。因此方程有解，且有：  

$$
x=x_{0}+(m/d)t,\;\;y=y_{0}+(a/d)t(t为任意整数)
$$

均满足$a x-m y=b$，因而都是方程的解。  

现在来考虑不同余的解。如果两个解$x_{0}+(m/d)t_{1}$，$x_{0}+(m/d)t_{2}$同余，则有：  

$$
x_{0}+\left({\frac{m}{d}}\right)t_{1}\equiv x_{0}+\left({\frac{m}{d}}\right)t_{2}({\bmod{\ m}});\ \ ({\frac{m}{d}})t_{1}\equiv({\frac{m}{d}})t_{2}({\bmod{\ m}})
$$

由定理2.25 知，$t_{1}\equiv t_{2}(\mathrm{mod}\,\,\,d)$。因此，不同余解$x=x_{0}+(m/d)t_{1}$中的$t$ 可取自$d$的完全剩余系，特别地， $t$  可取自最小剩余系，故方程解共有 $\left(a,\ m\right)=d$ 个。  

上述定理的证明过程其实给出了同余方程的一种求解方法。

【例题2.25】求$9x\equiv12({\bmod{\mathrm{~}}}15)$的解。

【解】因为$^{(9,15)}=3$，3|12，因此本方程有解，且有3 个不同余解。  

首先求出一个特殊解，然后加上$15/3=5\$的倍数则可求出其余解。先用辗转相除法来求(9,15)：  

$$
15=1\cdot9+6,\;\;9=1\cdot6+3,\;\;6=3\cdot2
$$

得到$(9{,}15)=3$。 由后退过程得：  

$$
3=9-1\cdot(15-1\cdot9)=2\cdot9-15
$$

由最大公因数的求法知存在$x,\ y$，使得$9x-15y=3$，因而存在$x,y\,$使得：  

$$
9x-15y=12
$$

由于$12=8*9-4*15$，故可求得$x_{0}=8$是其一个解，然后在：  

$$
x\equiv x_{0}+(15/3)t({\bmod{\ m}})
$$

中分别取$t=1$，2，进而得$\cdot x_{1}=8+5=13$；$x_{2}\equiv(8+10)({\bmod{\ }}15)$，即$x_{2}=3$  

考虑同余方程$a x\equiv1({\bmod{{m}}})$，由定理2.26，它有解当且仅当$\left(a,\ m\right)=1$，并且只有一个非同余的解，因此所有解是模$m$ 同余的。

在解一元一次方程的时候，经常将等式两边同时乘以未知数一次项系数的倒数，将未知数一次项的系数化为1，由此实现对方程组的求解。现通过类似方法对同余方程求解。  

对于任意给定的正整数$m$ 和整数$a$，如果存在一个相应的整数$\bar{a}$，满足：  

${\bar{a}}\cdot a\equiv1({\bmod{m}})$

则根据未知整数 $x$  同余关系的自反性 $x\equiv x({\bmod{{m}}})$ ，有： $\bar a \cdot a \cdot x \equiv x(\mod m)$

在同余方程两边同时乘以$\bar{a}$，得到：  

$$
{\bar{a}}\cdot a\cdot x\equiv{\bar{a}}\cdot b({\mathrm{mod}}\,\,\,m)
$$

由同余关系传递性可知，$x$ 与${\bar{a}}\cdot b({\mathsf{m o d}}\ m)$同余，即有：$x\equiv\bar{a}\cdot b(\mathrm{mod}\,\,\,m)$，由此实现求解。  

因此，若能求出$\bar{a}$，便可轻易实现对同余方程的求解。  

对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  

【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  

下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  

【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  

【证明】由定理2.6 中所说的线性组合及$\operatorname*{gcd}\!\left(a,\ m\right)=1$知，有整数$\cdot k_{1}$和$k_{2}$使  

$$
\boldsymbol{k}_{1}\cdot\boldsymbol{a}+\boldsymbol{k}_{2}\cdot\boldsymbol{m}=1
$$

即有：$k_{1}\cdot a+k_{2}\cdot m\equiv1({\bmod{{m}}})$。由于$\cdot k_{2}\cdot m=0({\bmod{\mathrm{~}}}m)$，故有：  

$$
k_{1}\cdot a\equiv1({\bmod{{m}}})
$$

因此，$k_{1}$为$a$ 的模$m$ 的逆。

定理2.27 的证明同时也给出了一个在$a$ 与$m$ 互素的条件下求$a$ 的模$m$ 逆的方法：求$a$和$m$ 的线性组合使之等于1（按欧几里得算法步骤倒过来做即可）；这一线性组合中$a$ 的系数就是$a$ 模$m$ 的一个逆。下面的例子说明了这一过程。  

【例题2.26】求3 的模7 逆。  

【解】由于$\operatorname*{gcd}(3,7)=1$，故存在3 模7 的逆。用欧几里得算法求3 和7 的最大公约数：  

$$
7=2\cdot3+1.
$$

$$
-2\cdot3+1\cdot7=1
$$

这说明−2 是3 模7的一个逆。(注意：模7 同余−2的每个整数也是3 的逆)

有了$a$ 模$m$ 的逆$\bar{a}$之后，就可方便地求解同余方程$a x\equiv b({\bmod{\ m}})$：只要在线性同余式两边同乘以$\bar{a}$即可。下面举例说明了这一过程。  

【例题2.27】 线性同余$3x\equiv4({\bmod{\mathrm{~}}}7)$的解是什么？

【解】从上一例题知道−2 是3 模7的逆。在同余式两边同乘以$-2$得  
$$
-2\cdot3x\equiv-2\cdot4({\bmod{\mathrm{~}}}7)
$$

因为$-6\equiv1(m o d\;\;7)$且$-8\equiv6(m o d\;\;7)$，所以若$x$是解，必有：  

$$
x\equiv-8\equiv6(m o d\;\;7)
$$

故有：  

$$
3x\equiv3\cdot6=18\equiv4({\bmod{\mathrm{~}}}7)
$$

这说明所有这种$x$ 满足问题中的同余式。结论是，同余方程的解是使$x\equiv6(m o d\;\;7)$的整数，即6, 13,20, ⋯及${-1,-8,-15}$，⋯。

【例题2.28】利用模的逆求同余方程$.7x\equiv22({\bmod{3}}1)$的解。  

【解】因为$(7,31)=1$，故只有一个不同余的解。由$7*9\equiv1({\bmod{\ }}31)$知9 是7 的模31的逆。在$7x\equiv22({\bmod{\mathrm{~}}}31)$两边乘9，得到：  

$$
7\cdot9x\equiv22\cdot9({\bmod{\ }}31)
$$

由于$7\cdot9\equiv1({\bmod{\ }}31)$，故其唯一不同余解为：  

$$
x\equiv21*9({\bmod{\mathrm{~}}}31)
$$

因此$x\equiv198\equiv12({\bmod{\,}}\,31)$为原方程的解。现进一步考察同余方程组及其解法，首先给出线性同余方程组的定义：  

【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  

$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$

若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  

当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  

【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。  

【证明】首先构造一个联立解，以满足同余式组（2-14）中的每个同余方程：记$M_{i}=M/m_{i}$，$1\leq i\leq k$，由于$m_{1}$，$m_{2},\ \ \cdots m_{k}$两两互素，故有：  

$$
(M_{i},\ m_{i})=1\,\mathrm{.}
$$

根据定理2.27，可求出$M_{i}$的模${{\mathbf{\nabla}}_{i}}$的逆$y_{i}$，即有：$M_{i}\;\;y_{i}\equiv1(m o d\;\;m_{i}).$

令$x=a_{1}M_{1}y_{1}+a_{2}M_{2}y_{2}+\cdots+a_{k}M_{k}y_{k}\,.$。则对任意$1\leq i\leq k$，因为$i\neq j$时$|m_{i}|M_{j}$，故有：  
$$
M_{j}y_{j}\equiv0({\bmod{m_{i}}})
$$

即有：  

$$
x\equiv a_{i}M_{j}y_{j}\equiv a_{i}({\bmod{{m_{i}}}})
$$

故$x$是所有同余方程公共解。  

其次，证明任何两个解均模$M$同余：假设$x_{0}$，$x_{1}$是任意两个同余式组的解，则有：  

$$
x_{0}\equiv x_{1}\equiv a_{i}({\bmod{m_{i}}})
$$

因此$m_{i}|(x_{0}-x_{1})$。 由于$m_{i}$两两互素，故$M|(x_{0}-x_{1})$，即有$x\equiv x_{0}(m o d\,\,\,M)$。因此同余式组（2-14）的模$M$ 不同余解是唯一的。

【例题2.29】 求整数$n$，它被3，5，7 除的余数分别是1，2，3。  

【解】设$n$ 是同余方程组  

$$
\begin{array}{r}{\left\{\begin{array}{l l}{n\equiv1(\bmod~3)}\\ {n\equiv2(\bmod~5)}\\ {n\equiv3(\bmod~7)}\end{array}\right.}\end{array}
$$

的解。根据定理2.28，取$m_{1}=3,\;\;m_{2}=5,\;\;m_{3}=7,\;\;M=3\times5\times7=105$，则有：  

$$
M_{1}=35\,,\;\;M_{2}=21\,,\;\;M_{3}=15
$$

由$35y_{1}\equiv1({\bmod{\ 3}})$，得：$2y_{1}\equiv1({\bmod{{3}}})$，$y_{1}\equiv2({\bmod{\ 3}})$  

由$21y_{2}\equiv1({\bmod{\mathrm{~}}}5)$，得：$y_{2}\equiv1({\bmod{\mathrm{~}}}5)$

由$15y_{3}\equiv1({\bmod{\mathrm{~7}}})$，得：$y_{3}\equiv1({\bmod{\mathrm{~7}}})$  

故有：  

$$
n\equiv1\times35\times2+2\times21\times1+3\times15\times1\equiv157\equiv52({\mathrm{mod~}}105)
$$

即 $n\equiv52({\bmod{\pmod{105}}})$ 为同余方程组的联立解。  

因此，所求整数为：$n\equiv52+105t$，$t\in Z$。

### 2.2.3 整数加密算法  

为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  

仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  

$$
f(p)=(p+3)\;{\bmod{\,}}26
$$

对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  

表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  

解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  

$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$

解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  

RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  

【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  

$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$

其中$\varphi(m)$是欧拉函数。  

【证明】设$\{x_{1},x_{2},\cdots,x_{\varphi(m)}\}$是模$m$ 的一个简化剩余系，由于$(a,\ m)=1$，从而：  

$$
a x_{1},\ \ \ a x_{2},\ \ \cdots,\ \ a x_{\varphi(m)}
$$

也是与$m$ 互素的$\varphi(m)$个整数，且当$1\leq i$，$j\leq\varphi(m)$，$i\neq j$ 时，有：  

$$
a x_{i}\not\equiv a x_{j}\:\:(m o d\:\:m)
$$

即这$\varphi(m)$个数两两不同余，否则导致 $x_{i}\equiv x_{j}(m o d\,\,\,m)\,\mathrm{.}$  

据此及$\left(a,\ m\right)=1$，并根据定理2.28，知：对每个$1\leq i\leq\varphi(m)$都能找到唯一的一个$1\leq j\leq\varphi(m)$，使得$a x_{i}\equiv x_{j}(m o d\,\,\,m)$，且这种对应是一对一的，故有：  

$$
a x_{1}a x_{2}\cdots a x_{\varphi(m)}\equiv x_{1}\;\;x_{2}\;\;\cdots\;\;x_{\varphi(m)}(\mathrm{mod}\;\;m)
$$

$$
\imath^{\varphi(m)}x_{1}\;\;x_{2}\;\;\cdots\;\;x_{\varphi(m)}\equiv x_{1}\;\;x_{2}\;\;\cdots\;\;x_{\varphi(m)}(\mathrm{mod}\;\;m)
$$

由于$\left(x_{1}\;\,x_{2}\;\,\cdots\;\,x_{\varphi(m)},\,\;m\right)=1$，故有：$a^{\varphi(m)}\equiv1(\,m o d\,\,m)$。证毕! 

我们知道，判定整数$p$ 为素数的一个重要方法是证明它不能被任何小于或等于其平方根的素数整除。但是，这种判定方法的效率并不高。我们中国古代数学家给出了一个大胆猜想，就是$p$ 为素数的充分必要条件是其满足公式$\cdot2^{p-1}\equiv1({\bmod{\,}}\,p)\,.$。  

如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  

【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  

$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$

特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  

【证明】若$\left(a,\,\,\,p\right)=1$，因为与$p$ 互素的数有$p-1$个，即$\varphi(p)=p-1$，由定理2.29 得到 $a^{p-1}\equiv1({\bmod{p}})$ ，进而 $a^{p}\equiv a({\mathrm{~mod~}}\,p).$ 。  

若 $\left(a,\,\,\,p\right)>1$ ，则 $p|a$ ，故有： $a^{p}\equiv0({\mathrm{~mod~}}p)\equiv a({\mathrm{~mod~}}p)$ 。证毕。

【例题2.30】利用费马小定理计算$3^{201}(\mod 11)$ 

【解】11 是素数，3 和11 互素，由费马小定理$3^{10}=1({\bmod{11}})$，因此 $3^{201}=3(3^{10})^{20}\equiv(1)^{20}3\equiv3({\bmod{1}}1)$  

故有： $3^{201}({\bmod{1}}1)=3.$ 

下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  

1） 密钥的生成  

首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  

然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  

$2\leq e\leq\varphi(n)$  

其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  

由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  

由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  

$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$

整数$d$ 属于解密密钥，不可对外公开。  

由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  

2） 加密过程  

在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  

RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  

$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$

在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  

3） 解密过程  

由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  

$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$

也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  

$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$

故有：  

$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$

假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  

$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$

从而有：  

$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$

由于$p$ 与$q$ 互素，则根据中国余数定理，有：  

$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$

由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  

因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  

在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  

RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  

1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  

2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  

3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  

并把满足这些条件的素数称为安全素数。  

【例题2.31】使用RSA 算法为信息“GOOD”加密，已知$\boldsymbol{\dot{p}}=43$，$q=59$，$e=13$【解】根据题意，有：$n=p\cdot q=43\cdot59=2537$。又因为：  

$$
\operatorname*{gcd}\!\left(e,\;(p-1)(q-1)\right)=\operatorname*{gcd}(13,\;42\cdot58)
$$

因此，整数$p,q,e$满足RSA 加密算法的约束条件。  

首先，将“GOOD”字母转换成相应的数字。具体做法与凯撒密码算法相同，采用0 到25  这 26  个正整数代表 A  到 Z  这 26  个大写字母。 G  对应的正整数为 06 ， O  对应的正整数为 14，D 对应的正整数为03，所以GOOD 对应的数字码为06141403。  

然后，将上面数字码按4 个数字一组分段为：0614   |  1403  

使用映射$C=M^{e}$  (mod$n$)得到：  
$$
C=0614^{13}(mod 2537)
$$
$C=0614^{13}(mod 2537)$  的计算并不是一件简单的事情。下面针对其一般情形$\cdot a^{b}$𝑚𝑜𝑑 $c$给出一种快速计算方法：  

在计算$a^{b}m o d$ 𝑐时，需要更新一个三维数组$(X,M,Y)$，其初始值为$(a,b,1)$，每一步的运算过程如下：  

如果$M$是奇数，则使用𝑋× 𝑌𝑚𝑜𝑑 $c$取代𝑌，用$M-1$取代$M$，$X$的值保持不变；  

如果$M$是偶数，则使用$X\times X m o d$ $c$取代$X$，用$M/2$取代$M$，𝑌的值保持不变；  

如果$M=0$时，则对应于$Y=a^{b}m o d\;\;c$  

该方法的基本思路是：通过不断折半或减1 的方式，将𝑀的值由最初从比较大的自然数$b$快速减小到0，当$M=0$，𝑌值即为所求的余数。方法的基本原理见关于同余幂的参考文献，这里不再赘述。例如，算式720𝑚𝑜𝑑 561的计算过程如表2-4 所示：  

表2-4 快速求余计算方法
![](images/f31ccb7e80bc0d4d43d2bff9ea188845770ca799f824838231f0a035f4adc643.jpg)  

因此，$7^{20}𝑚𝑜𝑑561 =463 $ 。

使用上述快速计算方法，计算出$C$ 的取值实现为每一段数字加密，即有：  

$$
0614^{13}{\pmod{2537}}{=}1422
$$

$$
1403^{13}{\pmod{2537}}{=}1384
$$

得到密文为14221384  

密文接受者在收到上述密文时，需要对其进行解密。由于已知密文是由：  

$$
n=p\cdot q=43\cdot59=2537
$$

和指数13 加密。  

因此，在解密时可以使用$d=937$（937 是13 模2436 的逆）作为解密指数。将需要解密的数字块$C$，通过计算$M=C^{937}$ (mod2537) 就可以得到明文。  

具体地说，就是采用前述快速方法计算得到：  

$$
1422^{937}\;({\mathrm{mod}}2537){=}0614
$$

$$
1384^{937}\;({\mathrm{mod}}2537){=}1403
$$

由此获得明文的数码形式06141403，将其转换成字母便得到明文GOOD。 

从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。  

## $\S\ 2.3$ 算法设计的基本知识  

在前面整数理论中有不少关于整数的算法，例如求最大公因数的辗转相除算法、素数查找算法、 凯撒整数加密算法、 RSA  整数加密算法等等。 所谓算法， 简单地说就是算术之法， 也就是说通过运算的方式按照机械的步骤逐步实现对问题的求解。算法的这种基于构造性和机械性的运算体系非常契合计算机的运算特点和需求。因此，随着计算机的诞生和兴起，算法设计理论与技术迅速得到广泛重视和深入研究。目前，除了整数理论之外，在离散数学的其它内容中很多也都是通过一些非常精彩算法形式为计算机提供服务。为更好地学习离散数学及其应用知识，本节简要介绍算法设计的基本知识。  

### 2.3.1 算法的基本概念  

计算机是处理数据并将数据转化为有用信息的电子设备。任何计算机都由程序指令控制，程序指令规定计算机的用途，并告诉计算机需要完成的工作。因此，要使计算机工作就需要编写计算机程序，告诉计算机如何按照步骤执行程序，以实现最终目标。值得注意的是：根据计算机的特点，在告诉计算机需要它完成什么任务的同时，还需要进一步确定或选择让它怎样去完成，这正是计算机算法的由来。  

算法一词出自《周髀算经》，即算术之法。目前，关于算法的概念有很多种不同的定义，至今没有一种得到大家的公认，但可从这些不同定义中找到一些基本的共识。为求同存异，现从广义和狭义这两个不同的角度来诠释与理解算法的概念。  

【定义2.17】从广义上讲，算法是指通过运算的方式按照某种机械的步骤逐步实现对问题的求解，从这个角度看，现实生活中的很多工作流程都可以看成是算法，例如烧菜的菜谱、理发的流程等，都可以叫算法。从狭义上讲，算法是一个由已知推求未知的过程，对于符合一定规范的输入，它能够在有限的时间内获得所需的输出。在计算机专业领域，主要是从狭义的角度来理解算法。  

本书的算法设计，主要是从计算机专业角度来理解算法。在计算机专业领域，对算法的理解不仅是狭义的，而且对算法概念诠释更加明确具体，即：算法是指用于计算机解决问题的清晰有穷指令序列，且满足以下五条基本性质：  

1) 有穷性：算法中每条指令的执行次数和时间均有限。执行次数或执行时间无穷的算法，对实际生产生活几乎没有意义，而且还会造成资源浪费。  

2) 确定性：对算法的描述必须无歧义，以保证算法执行结果是确定的，且符合要求和期望。如果算法对于同样的输入，在相同环境下产生不确定的结果，则是不能接受的。  

3) 输入：一个算法有0 个或多个输入，以确定运算对象的初始情况。所谓0 个输入是  

指算法本身给定了初始条件。  

4) 输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的。  

5) 可行性：算法中有待实现的运算都是基本运算，算法原则上要能够精确地运行，且人们用笔和纸做有限次运算后就可以完成。  

从计算机专业角度来看，一个完整的算法应该具备如下三个基本要素：  

1) 基本运算和操作  

算法的实现形式有多种，但是这些实现形式都具有相同的基本运算和操作。这些基本运算和操作有以下四类：  

算术运算：加减乘除等运算；关系运算：大于、小于、等于、不等于等运算；逻辑运算：或、与、非等运算；数据操作：输入、输出、赋值等运算。  

2) 控制结构  

一个算法的功能结构不仅取决于所选用的操作，而且还与各操作之间的执行顺序紧密相关。算法的控制结构确定了算法的基本框架，决定着各个操作的执行顺序。算法控制结构有三种，即顺序结构、选择结构和循环结构。  

3) 数据结构  

在计算机领域，算法的操作对象是数据。为了方便快速的存取，数据一般以一些特定的结构进行存储，另一方面，具体实际问题及其数学模型的结构特点决定了数据之间总是存在着一些特定的逻辑关系或逻辑结构。这些存储结构和逻辑结构统称为数据结构。  

一个算法可以采用多种不同的形式进行表示，常用的表示方法有：自然语言、流程图、伪代码等。本书后面各章节的算法将主要采用伪代码进行描述，以利于读者将理论与实际相结合，通过自己亲自动手描述和实现算法，加深对算法的理解。  

伪代码不是真正编程语言，而是一种算法描述语言，使用介于自然语言和程序设计语言之间的文字符号来描述算法。使用伪代码描述算法，能够使被描述的算法可以容易地以任何一种编程语言实现。伪代码可以综合使用多种编程语言中的语法、保留字，甚至会用到自然语言。 因此，伪代码结构清晰，简单且易于修改，可读性较好，并且类似自然语言。  

### 2.3.2 算法效率的度量  

从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  

因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  

事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  

对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  

（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  

（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$； 

（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  

（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  

（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  

（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  

（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  

（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。  

### 2.3.3 算法设计应用举例  

【例题2.32】某国王大赦囚犯，让狱吏通过一排锁着的𝑛间牢房并且每通过一次，就转动一次这排牢房中某些门锁。门锁每转动一次, 原来锁着的就被打开, 原来打开的就被锁上。狱吏通过$n$次后，门锁为开的牢房中犯人被放出，门锁为锁上的牢房中犯人不得获释。门锁转动规则如下：狱吏第一次通过牢房，则要转动每一把门锁，即把全部锁打开；第二次通过牢房时，从第二间开始转动，每隔一间转动一次；第$k$次通过牢房时，从第$k$间开始转动，每隔𝑘-1 间转动一次。问：狱吏通过$n$次后，哪些牢房锁为打开？  

【解】 1）用一维数组$a[n]$记录 $n$个锁的状态：1对应着被锁上，0对应着被打开；2）第$i$ 个锁的一次开关状态变化用算术运算表示：$a[i]=1-a[i]$；  

3）第一次转动所有牢房，即$1,2,3,\cdots,n$号；第二次每隔一间转动一间牢房，即 ${2,4,6,\cdots}$号牢房；第$k$次是每隔$k{-}1$ 间转动牢房，则是$k$, $2k$, $3k$, $4k$, ⋯号牢房，即起点为$k$，公差也为𝑘的等差数列；  

4）经过$_{n}$次循环模拟狱吏的开锁过程后，当第$k$号牢房对应的数组元素$a[k]$为0时，该牢房的锁是打开的，其中的囚犯获得赦免。  

以锁转动一次为一个计算单位，则该算法的时间复杂度为：  

$$
n+n/2+n/3+\cdots+1=O(n l o g\,n)
$$

【例题2.33】（找假币问题）有12 枚外观相同的硬币，要么全是真币，要么仅有一枚是假币。我们并不知道假币比真币重还是轻，你可以使用一个没有砝码的两盘天平秤，确定是否所有的硬币都是真币。如果有假币，找出那个假币并判断假币和真币相比孰轻孰重。设计一个算法，能够在使用最少称重次数的情况下解决这个问题。  

【解】首先，对硬币从1 到12 进行编号，在第一次称量时，将硬币1,2,3,4 和5,6,7,8 分别放在天平的左右两个托盘上。根据每次的称量结果，用$<,=$和$\mid>$进行标记：$<$表示左边托盘中硬币的重量小于右边托盘中硬币的重量；$=$表示两个托盘中硬币的重量相等；$>$表示左边托盘中硬币的重量大于右边托盘中硬币的重量。对于最终的称量结果用“$=$”表示所有的硬币都是真币；如果一个数字后面紧跟“$+$”，则表示相应编号的硬币重量较重；如果数字后面紧跟“-”，则表示相应编号的硬币重量较轻。整个称量过程如图2-1 所示。在第一次称重之前要么所有的硬币都是真币，要么每一枚硬币都或轻(-)或重$(+)$。  

![](images/4a626102e2cb82499ac9b94d8154aa8711402a0147f14cf6e1892d15153f64d9.jpg)  
															图2-1 找假币问题称量过程  

由上述分析可知，解决该问题至少需要三次称量。该方案的魅力在于方案的对称性，即第二次称量包含相同的硬币，如果第一次称量时天平发生倾斜，不管朝哪个方向倾斜，那么，第二次称量都会用到相同的硬币，且随后的一轮称量会包含相同的硬币对。事实上，该问题有一个完全非适应性的解决方案，即第二次在天平上方哪些硬币进行称量并不依赖于第一次称量结果，且第三次称量哪些硬币也不依赖于第一次和第二次的称量结果，读者可做进一步了解。可以证明当$n\geq3$时，该问题最佳算法至少需要$\lceil l o g_{3}(2n+3)\rceil$次称量。

【例题2.34】（受限汉诺塔问题）有$\cdot_{n}$个不同大小的盘子和3 根柱子，最初，所有的盘子都按大小顺序放置在第一根柱子上面，最大的在最下面，最小的在最上面。现在想要将所有的盘子都移动到第三根柱子上面去。一次只能移动一个盘子，而且禁止将大盘子放在小盘子上面。此外，每次移动要么在中间柱子上面放置一个盘子，要么从中间柱子上面取走一个盘子，如图2-2 所示。设计一个算法来求解该问题，使得所有的移动次数最小。  

![](images/669b81e931cd338c34f98762a7def08f0a2afa9b2d3f14f5117cdaf7e70cb9a9.jpg)  
图2-2 受限汉诺塔问题  

![](images/f182e0fd8bd860a3f05759ac0ac9e8b5e9355a54412eecd69208c2c557952184.jpg)  
图2-3 第一步移动结果图  

【解】如果$_{:n=1}$，从源柱子移动一个盘子到中间的柱子，然后再从中间的柱子移动到目的柱子。如果$n>1$，则按照如下步骤实施：  

1） 通过中间柱子，递归地从源柱子移动上面$n-1$个盘子到目的柱子，如图2-3 所示

2） 将源柱子上最下面的盘子移动到中间柱子上，如图2-4 所示。  

![](images/9fb63cadfdab10001a9bfb107604d017b4d51c61e855482e28ac1d0823b8185d.jpg)  
图2-4 第二步移动结果图  

![](images/21956be6cace9424502f8be4f6c28034f7d877fbd7e6450f88bbf18b531d8503.jpg)  
图2-5 第三步移动结果图  

3） 通过中间的柱子，递归地从目的柱子上移动𝑛−1个盘子到源柱子，如图2-5 所示。

4） 将中间柱子上的盘子移动到目的柱子上，如图2-6 所示。  

![](images/a3263eae2251ac07add00f556e91d52b55c8d69fd7fcbc843a30d23952c7b6c8.jpg)  
图2-6 第四步移动结果图  

![](images/e563dfbde2f6db36edb697953ff015c3ac4c29bedccaa2c9ff979cd197a84c1e.jpg)  
图2-7 第五步移动结果图  

5） 通过中间的柱子，递归地从源柱子移动𝑛−1个盘子到目的柱子上，如图2-7 所示。由以上分析可知，移动步数的递归关系$M(n)$如下：  

$$
M(n)=3M(n-1)\,,\,\,\,n\,\,\,>1\,,\,\,\,M(1)=2\tag{2-20}
$$

我们可以列出最前面几个$M(n)$的值：$M(1)=2$，$M(2)=8$，$M(3)=26$，$M(4)=80$。  

从这些数字看出，该问题的答案可以用公式$\ \vert M(n)=3^{n}-1$表示。该公式可以通过递归使用替代法获得：  

$$
M(n)=3^{n}-1,\ \,3M(n-1)+2=3(3^{n-1}-1)+2=3^{n}-1
$$

可以使用归纳法证明上述算法是在移动步数最少的情况下的解决方案。令$\cdot A(n)$为解决该问题的某种算法的移动步数。归纳法证明过程如下：  

当$n=1$，$A(1)\geq3^{1}-1$成立。现在假定该不等式对于$\cdot n\geq1$个盘子成立，再考虑$n+1$个  

盘子。在最大的盘子移动之前，所有的$n$个小一些的盘子都必须位于目的柱子上。通过归纳假设，至少需要移动$3^{n}-1$次盘子。将最大的盘子移动到中间的柱子至少需要一次移动。然后在把最大的盘子移动到目的柱子之前，所有的$n$个小一点的盘子都必须位于左边的柱子；通过归纳假设，至少需要移动$3^{n}-1$次盘子将它们移动到那儿。将最大的盘子从中间柱子移动到右边的柱子，至少需要移动一步，将$n-1$个盘子从左边的柱子移动到右边的柱子也至少需要移动$3^{n}-1$次盘子。总结起来，该算法所产生的总的移动步数一定满足下面的不等式：  

$A(n+1)\geq(3^{n}-1)+1+(3^{n}-1)+1+(3^{n}-1)=3^{n+1}-1$ 证毕！ 

## $\S\ 2.4$ 算法设计策略与应用  

计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。  

### 2.4.1 蛮力与贪心  

计算机处理的对象及其结构都是离散的，对这种离散对象与结构的求解，显然有一种最直观、最基本的方法，就是枚举出所有可能状态，然后在这些状态中找到所需的解。这就是蛮力法。该方法最大优点就是普适性高，几乎可以解决任何问题，最大的缺点就是计算量太大，很多情况下不可行。此外，还有一种非常直观的、非常基本的方法，那就是贪心法。该方法在每一步都获得当前状态下最好的结果，通过使用局部最优解步步逼近的方式获得问题全局最优解。贪心法的优点是思想直观，易于理解，缺点是算法没有总体控制机制，缺少远见和大局观，有时难以保证算法的正确性。蛮力法和贪心法的共同特点是算法思想简单，易于理解，但都存在比较明显的局限性，在很多情况下难以直接使用。  

#### 一、蛮力策略  

【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  

从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  

蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  

（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  

（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  

（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  

1）找到枚举范围：分析问题，找到所涉及的每一种情况。

2）找到约束条件：解析约束条件，并用逻辑表达式表示。  

【例题2.35】如图2-8 所示，$A,B,C,D$分别代表4 个不同的城市，箭头上的数字表示各个城市之间的路线距离，其中每个城市之间都可以互通，设计一个方案，使得从某个城市出发，遍历所有的城市一次且仅一次，然后再回到出发的城市，并使得整个周游的路线最短。  

![](images/7c5ed605ddd6cea090dd4dc7d706f10df0ba70a38f1a7b19e31b2419e2cc279b.jpg)  
图2-8 城市路线图  

【解】不失一般性，假定出发城市和终止城市都是A（因为一个合法的周游方案是一个城市圈，因此这样的假定不会对问题产生影响）。由于该问题的规模比较小，只有4 个城市，我们使用蛮力法求解，如表2-5 所示，穷举了所有出发城市和终止城市都是$A$ 的周游方案。  

表2-5 周游方案
![](images/6082e8fa27f0f268854a3a48aeaf41e3d0b4ddf7da05e1ed905fc7a76253fac8.jpg)  

通过对所有周游方案的长度的比较，得到最佳的周游路线是$A\to B\to D\to C\to A$，或者是$A\to C\to D\to B\to A.$。事实上，这两条周游路线是等价的，这也提示我们，在枚举的时候，可以通过适当的控制手段，减少一半的枚举数量。

#### 二、贪心策略  

【定义2.19】贪心算法，就是从问题的某个初始解出发，通过在每一步构造当前状态下局部最优解的方式（即在每个局部阶段都贪心地做出当前状态下一个最优决策），一步一步地向全局最优解逼近，最终获取全局最优解。  

从算法设计的角度看，贪心算法具有思维复杂度低、代码量小、运行效率高、空间复杂度低等优点。但是，其局限性也是很明显的：贪心算法合理性的前提是每一步的局部最优解一定能够逼近到全局最优解，有时很难保证能够做到这一点，这称为贪心算法的非完美性。贪心算法从本质上缺少大局观思想，会给我们直接使用贪心算法带来很大的困难，因为有时很难找到一个简单可行并具有完美性的贪心思路，即使找到一个看上去很完美的贪心思路，也需要严格地证明其正确性。不过值得庆幸的是，虽然并不是所有问题都可通过贪心算法获得整体最优解，但是由此至少可以得到一个近似最优解。  

【例题2.36】大学中经常需要使用会议室进行学术研讨或商议其它事情。但会议室个数是有限的，应该如何在日常的工作学习中避免时间冲突，最高效地利用会议室呢？  

假设只有一个会议室，需要举行有 $n$场会议。每场会议都有开始时间𝑏和结束时间𝑒 （若前面一场会议结束的时间早于后面一场会议的开始时间，则称这两场会议之间没有冲突，否则称这两场会议之间有冲突）。下表2-6 表示每场会议的开始时间和结束时间。  

表2-6 会议室时间安排
![](images/078bb57e252cd0c99603912efe5130ab89f5d3818cdce97fdfb86a33d5ed4017.jpg)  

【解】可以使用用贪心算法解决这个问题。贪心策略如下：为了使得会议室能够满足更多同学和老师的需求，我们总是选择在当前状态下，结束时间最早且在时间安排上无冲突的会议，如此选择会使得剩余时间最多，以便安排后续会议。按上述标准，不断重复地进行局部最优选择，直至所有会议都安排上或者时间安排满，由此得到问题的最优解。具体实现过程如图2-9 所示。  

![](images/c4fdc42ad98c63555285325acd06ca54c3a6a553b8c5e166d16114d498bfb9b3.jpg)  
图2-9 会议室安排过程示意图  

根据算法思想，首先选取会议结束时间最早的会议，即会议1，其结束时间为4；当继续选择会议结束时间第二早的会议2 时，由于该会议开始时间与会议1 结束时间产生冲突，因此放弃会议2 的安排；继续选择第三早的会议3，，此时会议3 情况和会议2 情况类似，也不予安排；当继续选择会议结束时间第四早的会议4 时，由于会议4 的开始时间与会议1结束时间并未冲突，故可安排会议4；以此类推，不再赘述，完整过程参见图2-9。  

### 2.4.2 递归与分治  

递归是算法设计中一项非常重要的策略，其基本思想是把一个问题归结为一个或多个规模更小的子问题，然后用同样的方法解规模更小的子问题，要求子问题与原问题保持同一类型以保证可用同样方法求解，如此下去，直到子问题的规模小到可以直接求解为止。分治策略的思想则是将一个难以解决的大问题，分割成一些与原问题相同的、规模较小的子问题，以便分而治之，然后递归地解决子问题，最后把子问题的解组合成原问题的解。递归和分治就像一对孪生兄弟，经常同时应用在算法设计之中，并由此形成很多高效的算法。  

#### 一、递归策略  

【定义2.20】若一个算法通过把问题转化到带更小输入的相同问题的实例，来求解原来的问题，则这个算法称为递归的。  

其算法思想就是把求解的问题转化成规模较小的子问题，然后，再把该子问题继续转化为更小的子问题，通过多次转化，使得问题的规模小到可以直接求解，并得到最小解，然后将最小解逐层向上返回调用，最终得到整个问题的解。通俗地说，递归法就是大事化小、小事化了。例如，求两个正整数$a$ 和$b$ 的最大公因子的问题，其中$b{>}a$，就可以转化到求一对更小的整数（即$b$ 𝑚𝑜𝑑 $a$ 和$a$）的最大公因子问题，因为gcd($\cdot b$𝑚𝑜𝑑 $a,\ a)=\operatorname*{gcd}(a,\ b)$。  

递归算法有三个基本要求：  

（1）递归中每次循环都必须使问题规模变小；  

（2）递归操作中每相邻两步都是紧密关联的，在递归返回到上一层的操作中，前一次的输出便是后一次的输入；  

（3）当子问题的规模足够小时，必须能够直接求出该子问题的解，也就是说必须具备结束递归的初始条件（即得到递归出口：当问题规模 $n$小到某个值时，能够直接求解）。  

【例题2.37】阶乘函数的递归定义：  

$$
n!=\left\{\begin{array}{r l r l}{\begin{array}{r l}{1}&{{}}&{\quad}&{{},n=0}\\ {\quad}&{{}}&{n\times(n-1)!}&{{}}&{,n>0}\end{array}}\end{array}\right.\tag{2-21}
$$

其中，自变量$n$为自然数。  

当$n=0$时，这个函数的初始值为1，即递归出口，是非递归定义的。每个递归函数都必须有非递归定义的初始值，否则，递归函数就无法计算。  

当$n>0$时，$n$的阶乘等于$\cdot n$乘它前一项的阶乘，具备了第一个要素：用较小自变量的函数值来表示较大自变量的函数值，使问题规模变小。关系式左右两边都引用了阶乘记号，是一个递归定义式，可递归地进行计算。  

设$T(n)$表示求解阶乘函数的时间，则算法的递归方程为：  

$$
T(n)=T(n-1)+O(1)\tag{2-22}
$$

其中$O(1)$为一次乘法操作，迭代求解过程如下：  

$$
{\begin{array}{r l}{T(n)=T(n-2)+O(1)+O(1)}\\ {=}&{T(n-3)+O(1)+O(1)+\ \ O(1)}\\ &{\dots}\\ {=}&{O(1)+\dots+O(1)+O(1)+\ O(1)}\\ &{{\mathrm{~}}\quad\quad\quad\quad\quad\quad=n\times O(1)}\end{array}}
$$

$$
=O(n)
$$

由上分析可知，求解阶乘函数的时间复杂度为$T(n)\ =O(n)$    

#### 二、分治策略  

【定义2.21】对于一个规模为$n$ 的问题，若该问题可以容易地解决（比如说规模$n$ 较小）则直接解决，否则将其分解为$k$个规模较小的子问题，这些子问题互相独立且与原问题形式相同，求解这些子问题，然后将各子问题的解合并得到原问题的解。  

如定义所述，由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术解  决并实现分治策略提供了方便。分治法也可以看成是一种递归，因为必要时可把分解求得的子问题的解合并起来获得原问题的解。  

分治算法一般分为如下三个基本步骤：（1）将原问题分解为若干相同的子问题；（2）若子问题的规模容易解决则直接求解，否则继续分解；3）将子问题的解合并得到原问题的解，当遇到如折半查找等某些不必求出所有子问题的解的情况时，则省略合并操作。  

分治算法的计算复杂性可以通过构造递推表达式进行分析：假设一个递归算法把一个规模为$n$ 的问题分成$a$ 个子问题，其中每个子问题的规模是$n/b$（为简单起见，假设$n$是$b$的倍数），并设在把子问题解组合成原问题解的处理中需要总量为$g(n)$的额外运算。  

【定义2.22】若$f\!\!\left(n\right)$表示求解规模为$n$ 的问题所需的运算数，则$f$满足如下递推关系：  

$$
f~(n)=a f(n/b)+g(n)\tag{2-23}
$$

上式称为分治递推关系。  

可通过上述递推关系来分析算法的复杂度。  

【定理2.31】假设$f$是满足递推关系：  

$$
f(n)=a f(n/b)+c
$$

的增函数，其中$n$ 被$b$ 整除，$a{\geq}1$，$b$ 是大于1 的整数，$c$ 是一个正实数。则有：  

$$
f(n)={\left\{\begin{array}{l l}{O(n^{l o g_{b}\,a})}&{{如果a>1}}\\ {O(l o g\,n)}&{{如果a=1}}\end{array}\right.}\tag{2-24}
$$

进一步，当$n=b^{k}$时（$k$ 是正整数），则有：  

$$
f(n)=C_{1}n^{l o g_{b}\,a}+C_{2}\tag{2-25}
$$

其中$C_{1}{=}f\!\!(1){+}c/(a{\cdot}1)$且$C_{2}=-c/(a-1)$  

【例题2.38】在一个有$2^{k}\times2^{k}(k\geq1)$个方格的棋盘上，有且仅有一个方格残缺，这样的棋盘称为残缺棋盘。图2-10 给出了当$k=1$时，各种可能的方格分布情况：  

![](images/9ed8fed7a5a58047fc37569d0be269694e8b5d073963aee26943bb4ccf372c71.jpg)  
图 $2\!\cdot\!10\!\!\!\mod\!\!k\!\!=\!\!1$  时的残缺棋盘  

![](images/fa917b3254c0bf413f4ee6ae0b9bb361d915844a0e09164636a62c34cf1db5c8.jpg)  
图 2-11  $k{=}2$ 时的残缺棋盘  

当$k=1$时是残缺棋盘的一种特殊情况，称为三格板，要求用这四种三格板覆盖整个残缺棋盘，并满足下述条件：  

条件一：两个三格板不能重叠；  

条件二：三格板不能覆盖残缺方格，但必须覆盖其他所有方格。  

【解】用分治法解决这个问题，首先考察当$k{=}2$ 时的情形。  

用二分法进行分解，得到如图2-11 所示的四个$\cdot k{=}1$ 的子棋盘。此时，显然不是所有子棋盘都是与原问题相似且独立的子问题。例如图${\operatorname{2-11}}(a)$的情况下，只有标号为1 的子棋盘中有残缺方格，其他子棋盘都是完整的，此时无法对整个问题做递归求解。  

为了达到递归目的，我们使用一个$a$号三格板覆盖2、3、4 三个子棋盘的各一个方格后，如图$2{\mathrm{-}}11(b)$图所示，把覆盖后的方格也看作是残缺方格，此时2、3、4 号子问题就是与原问题相互独立并且相似的子问题了。  

通过以上分析可以发现，当残缺方格在1 号子棋盘上时，用$a$ 号三格板覆盖其余三个子棋盘的交界处，可以使问题转化为独立相似的可求解子问题。类似地，当残缺棋盘在2号子棋盘时，可用$b$ 号三格板来覆盖；当残缺棋盘在3 号子棋盘时，可用$c$号三格板来覆盖；当残缺棋盘在4 号子棋盘上时，可用$d$ 号三格板来覆盖。  

类似地，$k=1{,}2{,}3{,}4{,}\cdots$ 都是如此，将原问题转换为4 个较小规模的子问题，可以递归使用这种分割，如图2-12 所示，当$k=1$时则到达递归出口。  

我们可以使用一个二维数组来模拟棋盘，如图2-13 所示。

易证覆盖残缺棋盘所需三格板数目为：$(s i z e^{2}-1)/3$  

因此，可将这些三格板编号为$1{\sim}(s i z e^{2}-1)/3$，并将覆盖残缺棋盘的相应各三格板区域编号统一存入二维数组的相应位置中。这样最后得到数组中数据就是问题的解。  

![](images/2aac37fe753a19dee897e32b4287e53a7f4b4c6298d42d464e2655d1753b1e7a.jpg)  
图 2-12 残缺棋盘的递归分割  					图 2-23 数组模拟棋盘

对于$2^{k}\times2^{k}$的残缺棋盘问题，证明其算法时间复杂度为$O(4^{k})$。  

【证明】设$T(k)$为覆盖$2^{k}\times2^{k}$棋盘的时间。当$k=0$时，覆盖棋盘所需要的时间为$O(1)$当$k>0$时，覆盖4 个特殊子棋盘需四次递归调用，共需时间$4T(k-1)$。  

因此，对于$2^{k}\times2^{k}$的棋盘，其递推关系式为：  

$$
T(k)=\left\{\begin{array}{r l r l}{\begin{array}{r l}O({1})&{{}}&{\quad}&{{},k=0}\\ {\quad}&{{}}&{4T(k-1)+O(1)}&{k>0}\end{array}}\end{array}\right.\tag{2-26}
$$

使用迭代方法求解这个递推关系：  

$$
\begin{array}{c}{{T(k)=4T(k-1)+O(1)}}\\ {{=4^{2}T(k-2)+4O(1)+O(1)}}\\ {{=4^{3}T(k-3)+4^{2}O(1)+4O(1)+O(1)}}\\ {{\ldots}}\\ {{=4^{k}T(0)+4^{k-1}O(1)+\cdots+4O(1)+O(1)}}\\ {{=4^{k}O(1)+O(1)\displaystyle\sum_{i=0}^{k-1}4^{i}=4^{k}O(1)+O(1)(4^{k}-1)/3}}\end{array}
$$

因此，覆盖$2^{k}\times2^{k}$规模棋盘的算法时间复杂度为：$T(k)=O(4^{k})$。 

### 2.4.3  回溯与动态规划  

回溯是一种基于解空间搜索的方法。基本思路类似于蛮力法，首先对所有的解状态进行枚举，生成解空间或状态空间，然后通过在解空间中搜索获得所需要的解。与蛮力法不同的是，这里的解空间是有结构的，换句话说，解空间以空间树的结构方式存在，由此可以根据这种特殊结构设计出很多高效的搜索方法。动态规划策略则是把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，通过对单阶段问题的逐个求解，实现对整个问题的求解，多年来，回溯和动态规划策略在最短路线、库存管理、资源分配、设备更新、排序、装载等问题求解算法中得到广泛应用。  

#### 一、回溯策略  

【定义2.23】回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。  

回溯法是一个既有系统性又有跳跃性的搜索算法，基本思路是在包含问题所有解的空间树中，按照深度优先的策略，从根节点出发搜索解的空间树。当算法搜索至某一节点时，先判断该节点是否包含问题的解，如果肯定不包含，则跳过以该节点为根的子树，逐层向其先前的节点回溯；否则，就进入该子树，继续按深度优先的策略进行搜索。回溯法的解空间为树结构，比较适合解决一些规模较大的问题。  

在用回溯法求解问题时，需要确定问题的解空间。所谓解空间，就是满足问题所有可能的解组成的集合，并且至少包含问题的一个（最优）解。  

由回溯法得到的解可以表示成$_{,n}$元向量$(X_{1},X_{2},\cdots,X_{n})$的形式。解向量一般具有显性或隐性的约束条件，在算法设计时，应该仔细分析，不能忽略。例如，当$n=3$ 时，0-1 背包问题可用一棵完全二叉树表示其解空间，如图2-14 所示。  

![](images/b415fb2b375de62d1f97720c41a6931e01b566d3978cde4ab5b4f6710e0bbacd.jpg)  
图2-14  $n{=}3$ 时背包问题的解空间  

在作为解空间的树结构中，从第𝑖层到第$i{+}1$ 层边上的标号给出了变量$X_{i}$ 的值。从树根到叶的任一路径表示解的空间中的一个元素，即一个具体的解向量。例如，从根节点$A$ 到叶子节点$H$ 的路径相应于解空间中的元素（1,1,1）。  

回溯算法需要搜索整棵解空间树，当问题规模很大时，计算量比较大。此时可用剪枝的方法对搜索策略进行优化。  

【定义2.24】剪枝就是通过某种判断避免一些不必要的遍历过程，剪去解空间树中的一些不必要的枝条，从而缩小搜索规模。  

剪枝函数通常有两种策略，一是用约束函数在扩展节点处剪去不满足约束条件的子树，二是用限界函数剪去不能得到最优解的子树。对于限界函数，一般是添加一个全局变量记录当前最优解，在到达节点时计算该节点预期值并与当前最优解比较，若不好，则回溯。  

综上所述，回溯法解题一般包括三个基本步骤：(1)定义问题的解空间；(2)确定解空间结构；(3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。  

![](images/94c98789a7564cef4defce6c521572031ed59be149b82dc63805c35507db88a6.jpg)  
图$2{\mathrm{-}}15\ 8{\times}8$ 棋盘  

【例题2.39】在$n{\times}n$格的棋盘上放置$n$个皇后，使其不能互相攻击，即任意两个皇后不能处于同一行、同一列或同一斜线上，问有多少种不同的放置方法。$n=8$时，即为著名的八皇后问题，如图2-15 所示。  

【解】$n$皇后问题的解空间是一棵排列树，在求解$_{\cdot n}$皇后问题时使用深度优先遍历方法遍历其解空间的排列树。在遍历过程中，如果当前位置无法满足放置条件则回溯到前一个位置继续遍历，当遍历至排列树的叶子节点且该条路径上经过的位置均满足放置条件时，则判断为找到一个解。以此方法遍历整个排列树即可找出$n$皇后问题的所有可行解。  

以四皇后问题为例，即$n=4$，在使用回溯算法搜索其解空间的排列树时过程如图2-16所示，图中$^{(a,b)}$表示皇后放置在第$a$ 行第$b$ 列。  

![](images/a82e8aee5329e550a2d57c1a00c5741eae69ab0dd03c999d4b48733b80e70e40.jpg)  
图2-16 四皇后回溯算法搜索图  

通过上述回溯搜索可知，对于图2-16 中虚线所示的一个可行解，4 个皇后在棋盘中的分布如2-17 左图所示。按同样方法，依次将第一个皇后放置在第1 行第3 列和第1 行第4列进行回溯搜索，就可以得到四皇后问题另外一个解，如2-17 右图所示。  

![](images/3f48402a537157d225b356ace22143039312c495c17e5f55901ea8e374f2cdbb.jpg)  
图2-17 四皇后问题可行解棋盘状态  

参照上述求解四皇后问题的思路，在求解$_{n}$皇后问题时，其实就是要解决好怎么放置这$n$个皇后，使得每个皇后与其前面所有皇后不能在同一行、同一列或同一斜线上。  

此处，我们以行优先，即皇后的行号按顺序递增，只考虑第𝑖个皇后放置在第𝑖行的哪一列，则具体步骤如下：  

在放置第𝑖个皇后的时候，从第1 列开始判断，若可以将其放在第1 个位置，则跳到下一行放置下一个皇后，否则跳到下一列并判断是否可以放置皇后，如此下去，直到判断到最后一列，如果最后一列也不能放置，则说明此时放置方法出错，应该回溯，把上一行皇后的位置往后移动一列，如果上一行皇后移动后也找不到位置，则继续回溯直至某一行找到可以放置皇后的位置，此即是回溯法的精髓所在。  

当第$n$个皇后放置成功后，即得到一个可行解。此时再回到上一个皇后重新放置寻找下一个可行解，如此下去，直到找出$n$皇后问题的所有可行解。  

在使用回溯法求解$_{\cdot n}$皇后问题时，需要定义一个数组$x[n]$来表示皇后的位置。其中数组元素的下标表示皇后所在的行，数组元素的值表示皇后所在的列。在判断第$n$行的皇后与前$_{n-1}$ 行皇后是否有冲突时，使用如下两个条件：  

a) $x[i]==x[n]$，即两皇后处于同一列；

 $b$) $|x[i]-x[n]|==|i-n|$，即两皇后处于同一斜线上$(i=0,1,\dots,n-1)$  

上述两个条件中任意一个成立则认为第$n$行的皇后与前$n-1$行皇后冲突。  

$n$皇后问题是一个经典趣味数学问题，本算法使用回溯策略求解$_{\cdot n}$皇后问题，算法中所有语句的频度之和为：$T(n)=2n^{3}+3n^{2}+2n+1$，故算法时间复杂度为$\,O(n^{3})$。 

#### 二、动态规划策略  

【定义2.25】动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。  

当问题的数学模型是递推式时，按理应该使用递归算法求解。但是，递归算法有时存在大量重复计算，使得算法时间复杂度过高。实际上，不同子问题的个数往往只有多项式数量级，若将已经计算过的子问题中间数据和计算结果记录下来，需要某个子问题的解时就直接调用，则可避免大量的重复计算，甚至可以获得多项式时间的算法计算量。动态规划算法正是遵循这种思想，将求解过程中所有子问题的解全部记录下来，不管该子问题以后是否会被其它子问题用到。可以看出，动态规划采用的是以空间换取时间的策略。  

动态规划法的有效性依赖于求解问题的两个重要性质，即：最优子结构性质和子问题重叠性质。  

$\bullet$ 最优子结构性质  如果问题最优解所包含子问题的解也是最优的，则称该问题具有最优子结构性质。最优子结构性质是动态规划求解问题的必要条件。

 $\bullet$ 子问题重叠性质  子问题重叠性质是指在用递归算法由自顶向下的方式对问题求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。当再次需要计算已经计算过的子问题时，无需再次计算，只需查表即可。 当确定待解决的问题可以使用动态规划算法求解时，通常按照以下几个步骤进行： 

（1）把所有最优化问题分成若干个阶段，找出最优解的性质，并刻画其结构特性。

 （2）将问题发展到各个阶段时所处的不同状态表示出来，确定各个阶段状态之间的递推（或递归）关系，并确定初始（边界）条件。 

（3）应用递推（或递归）关系求解最优值。 

（4）根据计算最优值时得到的信息，构造最优解。  

以上$(\,1\,)\,\sim\,(\,3\,)$步是动态规划算法解决问题的基本步骤，在只需要计算最优值的问题中，完成这三个基本步骤即可。  

如果问题需要构造最优解，仍需执行第（4）步；此时，在第（3）步通常需要记录更多的信息，以便在步骤（4）中有足够信息快速地构造出最优解。  

【例题2.40】一些硬币随机散步在$n\!\times\!m$ 的方格板上，一枚硬币占据一个方格，在板上左上角的方格里有一个机器人，它将尽可能多地收集硬币并把这些硬币带到最右下角的方格里，机器人向右或向下移动一格算作一步。每当机器人移动到一个方格就会收集该方格里的硬币。设计一个算法计算机器人所能收集硬币的最大数目以及相应的收集路径。  

【解】假设$C[i,j]$是机器人到达方格板第$i$行第$j$ 列的方格$(i,j)$时所能收集到硬币的最大数目。机器人要么是从上方的方格$(i-1,j)$，要么是从左侧的方格$(i,j-1)$到达这一点，这些棋格上所能收集到的最大硬币数目分别设为$C[i-1,j]$ 和$C[i,j-1]$，当然，第一行方格的上面是没有邻居的，第一列方格的左侧也是没有邻居的。对于这类不存在的邻居，$C[i-1,j]$和$C[i,j-1]$的值都等于0。因此，机器人到达方法$(i,j)$所收集的最大硬币数目等于$C[i-1,j]$ 和$C[i,j-1]$的最大值加上一个在方格$(i,j)$上可能存在的硬币数。换而言之，我们可以用以下公式计算$C[i,j]$：  

$$
C[i,j]=m a x\bigl\{C[i-1,j]\,,\,\,\,C[i,j-1]\bigr\}+c_{i j},\,\,\,1\leq i\leq n,1\leq j\leq m\tag{2-27}
$$

其中，如果方格$(i,j)$中有一枚硬币的话，$c_{i j}=1$，否则为$0$。当$1\leq j\leq m$时，$C[0,j]=0$；当$1\leq i\leq n$时，$C[i,0]=0$。  

利用上述公式，我们可以在$n\!\times\!m$ 的表格上逐行逐列地对$C[i,j]$进行填充，正如动态规划所展示的一样。对应于图2-18 左图所示的硬币布局，图2-18 右图展示了$C[i,j]$动态规划算法计算的结果，由于通过公式（2-27）计算每个方格的$C[i,j]$值花费常量时间，因此计算所有方格中值的算法的时间复杂度为$O(n m)$。  

![](images/add2931e8c68a4daec9cc40daee0c274eeb778c82dc58fbf4f0c44f2905c6dd8.jpg)  

![](images/30c0df952558f106018e699ea8732c76f7defac2a0aee109b40201680106ae0a.jpg)  
图2-19两条可能的路径  

经过以上分析，对于图2-18 左图所示的硬币布局，我们可以得到最大硬币收集数5 的两条可能路径如图2-19 所示。  

在寻找最优收集路径时，可以通过回溯计算得到收集最大数目的硬币所走的路径：如果$C[i-1,j]>C[i,j-1]$，到达方格$(i,j)$的最优路径肯定是来自其上方相邻方格；如果$C[i-$$1,j]<C[i,j-1]$，到达方格$(i,j)$的最优路径肯定是来自其左侧相邻方格；如果$C[i-1,j]=$$C[i,j-1]$，到达方格$(i,j)$的最优路径可能来自于上方相邻或者左侧相邻的方格，那么最优路径不唯一，它们都可能为最优路径中的一步。例如，图2-18 所示硬币分布做收集产生的两条最优路径。在使用回溯法寻找最优路径时，由于路径为从左上角到右下角，故算法可在$O(n+m)$时间内找到一条最优路径。  

由上分析可知，$n\!\times\!m$ 的方格板硬币收集算法的时间复杂度主要包括计算每个方格所能收集到的最大硬币数和寻找硬币收集路径两部分，故总的算法时间复杂度为$O(n m)+$  $O(n+m)=O(n m)$ 。

## $\S\ 2.5$习 题 <abd> 

1.判断下述命题是否为真： 3|7，5|-35，-1|-21，12|4，2|0，2|0，0|0  

2.求出下列整数数的非平凡因子： 60，238, 512, 707, 1000, 15！  

3.证明：如果$a|b$及$b|a$，其中$a$和$b$为整数，则必有$a=b$或$a=-b$

4.若 $a,b,c$ 为整数，且满足 $.a c|b c$ ，求证 $a|b$ 。

5.判断下列数是素数还是合数： 113，221，527，$2^{11}-1$。

6.证明:每个奇数的平方都形如$8k+1$(k是整数)。

7.证明:任意三个连续的整数的积都能被6整除。

8.求下列各组数的最大公约数和最小公倍数。  

（1）15,35 （2）100, 121 （3）72, 231 （4）154, 128  

9.设 $a,b$ 不全为零， $c\neq0\in\mathbf{Z}$ ，则 $gcd(c a,c b)=|c|gcd(a,b)$

10.求下列各种情况的商和余数：  

（1）19 除以7；（2）-111 除以11；（3）1001 除以13

（4）0 除以19；（5）-1 除以3；（6）3 除以5。  

11.求满足 $\operatorname*{gcd}(a,b)=10$ 且 $\operatorname{lcm}(a,b)=100$ 的所有正整数对 $a,b$ 。  

12.证明：对任意正整数  $a,b$ ， $a b=gcd(a,b)lcm(a,b)$

13. 用欧几里得算法求下列整数对的最大公因子并用线性组合表示：  

	(51.87)，(105.300)，(981.1234)，(34709，100313)

	

14. 设是a,b不全为零的整数且互素，计算$$gcd(a^2+b^2,a+b)$$

15. 判断下述正整数是素数还是合数： 101，111，213，221，$2^{11}-1$。

16. 给出下述各数的素因子分解： 204，512，3276，4025，20！。 

17. 利用素因子分解，求下述每一对正整数的最大公约数和最小公倍数。  

（1）165, 120  （2）36, 216  （3）215, 1100 

18. 下述每一对整数是否互素？若互素，求出整数$x,y$，使得$x a+y b=1$。

	（1）24, 35 （2）63, 91 （3）450, 539 （4）1024, 729  

19. 如果$k$是正整数，证明$3k+2$和$5k+3$互素。

20. 证明：若$2^{n}-1$是素数，则$n$是素数。  

21 .验证下列同余式：  

$\ \,(\,1\,)\ 13\!\equiv\!1(\mathrm{mod}\ 2);\ \,(\,2\,)\ 22\!\equiv\!7(\mathrm{mod}\ 5);\\(\,3\,)\ 69\!\equiv\ 62(\mathrm{mod}\ 7);(\,4\,)\ 111\!\equiv\!-9(\mathrm{mod}\ 40);$ 

22. 设$m$ 为正整数。求证：如果$a$ 𝑚𝑜𝑑 $m=b$ 𝑚𝑜𝑑 $m$，则有：$a\equiv b(m o d\,\,\,m)\,$

23. 证明：如果$a$是偶数，则$a^{2}\equiv0({\bmod{\mathrm{~}}}4)$如果a是奇数，则$a^{2}\equiv1({\bmod{\ 4}})\,$。

24. 证明：如果$a$是奇数，则$a^{2}\equiv1({\bmod{\mathrm{~}}}8)$。
24.  求下列最小正剩余：  

（1）6！mod 7  （2）10！mod 11 （3）16！mod 17  

26. 分别计算整数$2^{32}$、$2^{47}$、$2^{200}$ 模47 后的最小剩余系（即小于47 的最小正整数）。 

27. 写出全是奇数的模13 的完全剩余系以及全是奇数的模10 的完全剩余系.

28.  写出全是偶数的模9 简化完全剩余系. 能否给出全是偶数的模10 简化完全剩余系.

29.  使用费马小定理计算下列各式。  

$(1)\ \ \ 2^{325}mod \ 5 \ \ \ \ \ (2)\ \ \ 3^{516}mod\ 11\ \ \ \ (3)\ \ \ 8^{1003}mod\ 11$

30. 求线性同余方程组$x\equiv4(m o d\;\;11)$，$x\equiv3(m o d\;\;17)$的所有解。

31.  求线性同余方程组$x\equiv1(m o d\;\;2)$，$x\equiv2(m o d\;\;3)$，$x\equiv3(m o d\;\;5)$的所有解。

32.  求下列整数的模17 的一个逆：4，5,7,16 33.

33.  求一整数，它被10 或11 除余9，被13 整除。  

34. 有一队士兵，若三人一组，则余1 人；若五人一组，则缺2 人；若十一人一组，则余3 人。已知这队士兵不超过170 人，问这队士兵共有多少人？  

35. 为信息“DO NOT PASS GO”加密，先把字母翻译成整数，再用下面给的加密函数计算，然后把整数翻译成字母：  

	$(1)f(p)=(p+3)mod25(凯撒密码)\ \ \ (2)f(p)=(3p+7)mod\ 26$

36.为下列用凯撒密码加密的信息解密：  

（1）EOXH MHDQV  （2）WHVW WRGDB  （3）HDW GLP VXP  

37. 证明：对任意整数$^{.}a$， $\operatorname*{gcd}(a,561)=1$,有$a^{560}\equiv1(m o d\;\;561)$，但561 是合数。  

38. 设$p$, $q$是两个不同的素数，证明：$p^{q-1}+q^{p-1}\equiv1({\bmod{\ }}p q)\,.$  

39.考虑RSA 算法$p=11$，$q=9$，$n=319$，$e=3$，那么$d$应该是多少呢？待加密的明文为$\cdot M=100$，密文是多少？  

40. 在RSA 算法中，设张三的公钥是$e=3$。证明：如果敌人得到了张三的私钥$d$，那么敌人就有以$k$的多项式数量级的算法分解大整数$_n$，这里$k$为$n$的二进制表示长度。  

41. 有一批集装箱要装上一艘载重量为$c$的轮船。其中集装箱𝑖的重量为$W_{i}$。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。对于给定的$n$个集装箱和轮船的载重量$C$，设计算法并编程计算装入最多时的集装箱个数。  

42. 设有$\cdot_{n}$件工作分配给$n$个人。为第𝑖个人分配工作𝑗所需的费用为$𝑐[𝑖][𝑗] $。试设计一个算法，计算最佳工作分配方案，为每人都分配1 件不同工作，并使总费用达到最小。  

43. 一个长,宽,高分别是$m,n,p$的长方体被分割成$m\times n\times p$个小立方体。每个小立方体内含一个整数。试着设计一个算法，计算所给长方体的最大子长方体。子长方体的大小由它内部所含所有整数之和确定。  

44.  世界名画陈列馆由 $m\times n$ 个排列成矩形阵列的陈列室组成。为了防止名画被盗，要 在室中设置警卫机器人哨位。每个警卫机器人除了监视它所在陈列室外，还可监视与它所在的陈列室相邻的上、下、左、右4 个陈列室。试设计一个安排警卫机器人哨位的算法，使得馆中每一个陈列室都在警卫机器人的监视之下，且所用的警卫机器人数最少。  

45. 给定$n$个矩阵：$A_{1},A_{2},\cdots,A_{n}$，其中$A_{i}$与$A_{i+1}$是可乘的，$i=1$，2. . . ，$n-1$。确定计算矩阵连乘积的次序，使得依此次序计算矩阵连乘积所需的数乘次数最少。输入数据为矩阵个数和每个矩阵规模，输出为矩阵连乘积的计算次序和最少数乘次数。  

46. 设有6 种不同面值的硬币，分别为5 分，1 角，2 角，5 角，1 元，2 元。现用这些面值的硬币购物和找零。购物时可用的各种面值的硬币个数存于数组𝐶𝑜𝑖𝑛𝑠[1: 6]中，商店里各面值的硬币有足够多。在1 次购物中希望使用最少硬币个数。 例如，1 次购物需要付款0.55 元，没有5 角的硬币，只好用${2\!\times\!20\!+\!10\!+\!5}$ 共4 枚硬币来付款。如果付出1 元，找回4 角5 分，同样需要4 枚硬币。但是如果付出1.05 元（1 枚1 元和1 枚5 分），找回5 角，只需要3 枚硬币，这个方案用的硬币个数最少。 对于给定的各种面值的硬币个数和付款金额，设计使用硬币个数最少的交易方案。  